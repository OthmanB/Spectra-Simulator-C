<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ARMMSolver: /Users/obenomar/Documents/GitHub/ARMM-solver/bump_DP.cpp File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">ARMMSolver
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#define-members">Macros</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">/Users/obenomar/Documents/GitHub/ARMM-solver/bump_DP.cpp File Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Functions computing the full profile of the mixed modes as well as artificial asteroseismic parameters for a RGB stars.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &lt;Eigen/Dense&gt;</code><br />
<code>#include &lt;string&gt;</code><br />
<code>#include &lt;vector&gt;</code><br />
<code>#include &lt;iostream&gt;</code><br />
<code>#include &lt;iomanip&gt;</code><br />
<code>#include &lt;fstream&gt;</code><br />
<code>#include &quot;<a class="el" href="version__solver_8h_source.html">version_solver.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="data__solver_8h_source.html">data_solver.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="string__handler_8h_source.html">string_handler.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="interpol_8h_source.html">interpol.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="noise__models_8h_source.html">noise_models.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="solver__mm_8h_source.html">solver_mm.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="bump___d_p_8h_source.html">bump_DP.h</a>&quot;</code><br />
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="define-members" name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a889ec205c635b219999c761b28cc39ba" id="r_a889ec205c635b219999c761b28cc39ba"><td class="memItemLeft" align="right" valign="top"><a id="a889ec205c635b219999c761b28cc39ba" name="a889ec205c635b219999c761b28cc39ba"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>omp_get_thread_num</b>()&#160;&#160;&#160;0</td></tr>
<tr class="separator:a889ec205c635b219999c761b28cc39ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a8cf55c8478283af8616cd564787b4423" id="r_a8cf55c8478283af8616cd564787b4423"><td class="memItemLeft" align="right" valign="top">VectorXd&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bump___d_p_8cpp.html#a8cf55c8478283af8616cd564787b4423">ksi_fct1</a> (const VectorXd &amp;nu, const long double nu_p, const long double nu_g, const long double Dnu_p, const long double DPl, const long double q)</td></tr>
<tr class="memdesc:a8cf55c8478283af8616cd564787b4423"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the ksi function as defined in equation 14 of Mosser+2017 (<a href="https://arxiv.org/pdf/1509.06193.pdf">https://arxiv.org/pdf/1509.06193.pdf</a>).  <br /></td></tr>
<tr class="separator:a8cf55c8478283af8616cd564787b4423"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac13e6fb329a8ab7731d252b7e8d57fcf" id="r_ac13e6fb329a8ab7731d252b7e8d57fcf"><td class="memItemLeft" align="right" valign="top">Eigen::VectorXd&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bump___d_p_8cpp.html#ac13e6fb329a8ab7731d252b7e8d57fcf">ksi_fct2</a> (const Eigen::VectorXd &amp;nu, const Eigen::VectorXd &amp;nu_p, const Eigen::VectorXd &amp;nu_g, const Eigen::VectorXd &amp;Dnu_p, const Eigen::VectorXd &amp;DPl, const long double q, const std::string norm_method)</td></tr>
<tr class="memdesc:ac13e6fb329a8ab7731d252b7e8d57fcf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the zeta function for mixed modes in precise mode.  <br /></td></tr>
<tr class="separator:ac13e6fb329a8ab7731d252b7e8d57fcf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b087f1888177533f5001c70745b5bdc" id="r_a5b087f1888177533f5001c70745b5bdc"><td class="memItemLeft" align="right" valign="top">Eigen::VectorXd&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bump___d_p_8cpp.html#a5b087f1888177533f5001c70745b5bdc">ksi_fct2_precise</a> (const Eigen::VectorXd &amp;nu, const Eigen::VectorXd &amp;nu_p, const Eigen::VectorXd &amp;nu_g, const Eigen::VectorXd &amp;Dnu_p, const Eigen::VectorXd &amp;DPl, const long double q)</td></tr>
<tr class="memdesc:a5b087f1888177533f5001c70745b5bdc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the zeta function for mixed modes in precise mode.  <br /></td></tr>
<tr class="separator:a5b087f1888177533f5001c70745b5bdc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93fd38ebf1060eae35b27132c4646db6" id="r_a93fd38ebf1060eae35b27132c4646db6"><td class="memItemLeft" align="right" valign="top">VectorXd&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bump___d_p_8cpp.html#a93fd38ebf1060eae35b27132c4646db6">gamma_l_fct2</a> (const VectorXd &amp;ksi_pg, const VectorXd &amp;nu_m, const VectorXd &amp;nu_p_l0, const VectorXd &amp;width_l0, const VectorXd &amp;hl_h0_ratio, const int el, const long double factor)</td></tr>
<tr class="memdesc:a93fd38ebf1060eae35b27132c4646db6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the mode width of mixed modes based on the given ksi_pg, nu_m, nu_p_l0, width_l0, hl_h0_ratio, el, and a factor.  <br /></td></tr>
<tr class="separator:a93fd38ebf1060eae35b27132c4646db6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68f066f21a116c30448ba2ef92101dcf" id="r_a68f066f21a116c30448ba2ef92101dcf"><td class="memItemLeft" align="right" valign="top">VectorXd&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bump___d_p_8cpp.html#a68f066f21a116c30448ba2ef92101dcf">h_l_rgb</a> (const VectorXd &amp;ksi_pg, const long double factor)</td></tr>
<tr class="memdesc:a68f066f21a116c30448ba2ef92101dcf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the H(l)/H(l=0) ratio based on the given ksi_pg and a factor.  <br /></td></tr>
<tr class="separator:a68f066f21a116c30448ba2ef92101dcf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e0292785f729d13fe114ce0c8554129" id="r_a7e0292785f729d13fe114ce0c8554129"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structtemplate__file.html">template_file</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bump___d_p_8cpp.html#a7e0292785f729d13fe114ce0c8554129">read_templatefile</a> (const std::string file, const bool ignore_errors)</td></tr>
<tr class="memdesc:a7e0292785f729d13fe114ce0c8554129"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a template file and extracts relevant information.  <br /></td></tr>
<tr class="separator:a7e0292785f729d13fe114ce0c8554129"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af39be32ef8277be6aed321eed67a4684" id="r_af39be32ef8277be6aed321eed67a4684"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_data__2vect_xd.html">Data_2vectXd</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bump___d_p_8cpp.html#af39be32ef8277be6aed321eed67a4684">width_height_load_rescale</a> (const VectorXd &amp;nu_star, const long double Dnu_star, const long double numax_star, const std::string file)</td></tr>
<tr class="memdesc:af39be32ef8277be6aed321eed67a4684"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loads and rescales data from a file based on reference values.  <br /></td></tr>
<tr class="separator:af39be32ef8277be6aed321eed67a4684"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fc7fa1e50e82ef213ac96c86a23dc59" id="r_a7fc7fa1e50e82ef213ac96c86a23dc59"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_data__rot2zone.html">Data_rot2zone</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bump___d_p_8cpp.html#a7fc7fa1e50e82ef213ac96c86a23dc59">rot_2zones_v2</a> (const long double <a class="el" href="bump___d_p_8cpp.html#aab630af9de049c0647dfec3c1206a9ac">rot_envelope</a>, const long double core2envelope_star, std::string output_file_rot)</td></tr>
<tr class="memdesc:a7fc7fa1e50e82ef213ac96c86a23dc59"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the core rotation from the surface rotation.  <br /></td></tr>
<tr class="separator:a7fc7fa1e50e82ef213ac96c86a23dc59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37ce54feb9cd023be30b5e0f97f0bf88" id="r_a37ce54feb9cd023be30b5e0f97f0bf88"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_data__rot2zone.html">Data_rot2zone</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bump___d_p_8cpp.html#a37ce54feb9cd023be30b5e0f97f0bf88">rot_2zones_v3</a> (const long double <a class="el" href="bump___d_p_8cpp.html#aab630af9de049c0647dfec3c1206a9ac">rot_envelope</a>, const long double rot_core, std::string output_file_rot)</td></tr>
<tr class="memdesc:a37ce54feb9cd023be30b5e0f97f0bf88"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the core rotation from the surface rotation.  <br /></td></tr>
<tr class="separator:a37ce54feb9cd023be30b5e0f97f0bf88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab630af9de049c0647dfec3c1206a9ac" id="r_aab630af9de049c0647dfec3c1206a9ac"><td class="memItemLeft" align="right" valign="top">long double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bump___d_p_8cpp.html#aab630af9de049c0647dfec3c1206a9ac">rot_envelope</a> (long double med, long double sigma)</td></tr>
<tr class="memdesc:aab630af9de049c0647dfec3c1206a9ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the rotation in the envelope based on a truncated Gaussian distribution.  <br /></td></tr>
<tr class="separator:aab630af9de049c0647dfec3c1206a9ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56ec359e6f37d614f8ce604fe9ff4563" id="r_a56ec359e6f37d614f8ce604fe9ff4563"><td class="memItemLeft" align="right" valign="top">VectorXd&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bump___d_p_8cpp.html#a56ec359e6f37d614f8ce604fe9ff4563">dnu_rot_2zones</a> (const VectorXd &amp;ksi_pg, const long double <a class="el" href="bump___d_p_8cpp.html#aab630af9de049c0647dfec3c1206a9ac">rot_envelope</a>, const long double rot_core)</td></tr>
<tr class="memdesc:a56ec359e6f37d614f8ce604fe9ff4563"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the frequency splitting of modes assuming a two-zone rotation profile.  <br /></td></tr>
<tr class="separator:a56ec359e6f37d614f8ce604fe9ff4563"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4550aabd598313869e70af350ca319bc" id="r_a4550aabd598313869e70af350ca319bc"><td class="memItemLeft" align="right" valign="top">long double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bump___d_p_8cpp.html#a4550aabd598313869e70af350ca319bc">numax_from_stello2009</a> (const long double Dnu_star, const long double spread)</td></tr>
<tr class="memdesc:a4550aabd598313869e70af350ca319bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the value of numax based on the Dnu_star parameter using the relation from Stello+2009.  <br /></td></tr>
<tr class="separator:a4550aabd598313869e70af350ca319bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad899e3b2dcf1b28b9462239337a0462" id="r_aad899e3b2dcf1b28b9462239337a0462"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_params__synthetic__star.html">Params_synthetic_star</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bump___d_p_8cpp.html#aad899e3b2dcf1b28b9462239337a0462">make_synthetic_asymptotic_star</a> (<a class="el" href="struct_cfg__synthetic__star.html">Cfg_synthetic_star</a> cfg_star)</td></tr>
<tr class="memdesc:aad899e3b2dcf1b28b9462239337a0462"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates a set of mode parameters for simulating an evolved star based on the asymptotic relations.  <br /></td></tr>
<tr class="separator:aad899e3b2dcf1b28b9462239337a0462"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9502223abfcc241cd726424fd57b855a" id="r_a9502223abfcc241cd726424fd57b855a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bump___d_p_8cpp.html#a9502223abfcc241cd726424fd57b855a">displayCfgSyntheticStar</a> (const <a class="el" href="struct_cfg__synthetic__star.html">Cfg_synthetic_star</a> &amp;cfg)</td></tr>
<tr class="memdesc:a9502223abfcc241cd726424fd57b855a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Displays the values of the parameters in the <a class="el" href="struct_cfg__synthetic__star.html" title="Structure for synthetic star configuration data.">Cfg_synthetic_star</a> structure.  <br /></td></tr>
<tr class="separator:a9502223abfcc241cd726424fd57b855a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Functions computing the full profile of the mixed modes as well as artificial asteroseismic parameters for a RGB stars. </p>
<p>This file contains all the functions that describe the Bumped period spacing and how they can be used to derive mode amplitudes from inertia ratio. The functions have been developed and tested based on the following publications:</p><ul>
<li><a href="https://arxiv.org/pdf/1509.06193.pdf">Inertia and ksi relation</a></li>
<li><a href="https://www.aanda.org/articles/aa/pdf/2015/08/aa26449-15.pdf">Eq. 17 for the rotation - splitting relation</a></li>
<li><a href="https://arxiv.org/pdf/1401.3096.pdf">Fig 13 and 14 for the evolution - rotation relation in SG and RGB</a></li>
<li><a href="https://arxiv.org/pdf/1505.06087.pdf">Eq. 3 for determining log(g) using Teff and numax, used for getting the evolution stage in conjunction with Fig. 13 from above</a></li>
<li><a href="https://iopscience.iop.org/article/10.1088/2041-8205/781/2/L29/pdf">Inertia and Height relation</a></li>
<li><a href="https://arxiv.org/pdf/1707.05989.pdf">Fig.5, distribution of surface rotation for 361 RGB stars</a> </li>
</ul>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="a9502223abfcc241cd726424fd57b855a" name="a9502223abfcc241cd726424fd57b855a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9502223abfcc241cd726424fd57b855a">&#9670;&#160;</a></span>displayCfgSyntheticStar()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void displayCfgSyntheticStar </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_cfg__synthetic__star.html">Cfg_synthetic_star</a> &amp;&#160;</td>
          <td class="paramname"><em>cfg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Displays the values of the parameters in the <a class="el" href="struct_cfg__synthetic__star.html" title="Structure for synthetic star configuration data.">Cfg_synthetic_star</a> structure. </p>
<p>This function displays the values of the parameters in the <a class="el" href="struct_cfg__synthetic__star.html" title="Structure for synthetic star configuration data.">Cfg_synthetic_star</a> structure. The parameters include Teff_star, numax_star, Dnu_star, epsilon_star, and other parameters related to the synthetic star simulation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cfg</td><td>The <a class="el" href="struct_cfg__synthetic__star.html" title="Structure for synthetic star configuration data.">Cfg_synthetic_star</a> structure containing the parameters. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a56ec359e6f37d614f8ce604fe9ff4563" name="a56ec359e6f37d614f8ce604fe9ff4563"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56ec359e6f37d614f8ce604fe9ff4563">&#9670;&#160;</a></span>dnu_rot_2zones()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VectorXd dnu_rot_2zones </td>
          <td>(</td>
          <td class="paramtype">const VectorXd &amp;&#160;</td>
          <td class="paramname"><em>ksi_pg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const long double&#160;</td>
          <td class="paramname"><em>rot_envelope</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const long double&#160;</td>
          <td class="paramname"><em>rot_core</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the frequency splitting of modes assuming a two-zone rotation profile. </p>
<p>This function calculates the frequency splitting of modes based on a two-zone rotation profile. The rotation rates in the envelope and core are given as input parameters. The function also takes the ksi function, which describes the degree of mixture between p and g modes as a function of frequency.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ksi_pg</td><td>The ksi function that describes the degree of mixture between p and g modes as a function of frequency. </td></tr>
    <tr><td class="paramname">rot_envelope</td><td>The average rotation in the envelope. Must be a scalar. </td></tr>
    <tr><td class="paramname">rot_core</td><td>The average rotation in the core. Must be a scalar. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A VectorXd object containing the frequency splitting values. </dd></dl>

</div>
</div>
<a id="a93fd38ebf1060eae35b27132c4646db6" name="a93fd38ebf1060eae35b27132c4646db6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93fd38ebf1060eae35b27132c4646db6">&#9670;&#160;</a></span>gamma_l_fct2()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VectorXd gamma_l_fct2 </td>
          <td>(</td>
          <td class="paramtype">const VectorXd &amp;&#160;</td>
          <td class="paramname"><em>ksi_pg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VectorXd &amp;&#160;</td>
          <td class="paramname"><em>nu_m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VectorXd &amp;&#160;</td>
          <td class="paramname"><em>nu_p_l0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VectorXd &amp;&#160;</td>
          <td class="paramname"><em>width_l0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VectorXd &amp;&#160;</td>
          <td class="paramname"><em>hl_h0_ratio</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>el</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const long double&#160;</td>
          <td class="paramname"><em>factor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates the mode width of mixed modes based on the given ksi_pg, nu_m, nu_p_l0, width_l0, hl_h0_ratio, el, and a factor. </p>
<p>This function calculates the width_l vector by performing interpolation using the given ksi_pg, nu_m, nu_p_l0, width_l0, hl_h0_ratio, el, and factor. The width0_at_l is calculated using linear interpolation between nu_p_l0 and width_l0 for each element in nu_m. The width_l vector is then calculated by multiplying width0_at_l with (1. - factor*ksi_pg[i]) and dividing by the square root of hl_h0_ratio[i].</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ksi_pg</td><td>The ksi_pg vector. </td></tr>
    <tr><td class="paramname">nu_m</td><td>The nu_m vector. </td></tr>
    <tr><td class="paramname">nu_p_l0</td><td>The nu_p_l0 vector. </td></tr>
    <tr><td class="paramname">width_l0</td><td>The width_l0 vector. </td></tr>
    <tr><td class="paramname">hl_h0_ratio</td><td>The hl_h0_ratio vector. </td></tr>
    <tr><td class="paramname">el</td><td>The el value. </td></tr>
    <tr><td class="paramname">factor</td><td>The factor value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The width_l vector.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The size of nu_p_l0 and width_l0 must be the same. </dd>
<dd>
The size of ksi_pg and nu_m must be the same. </dd>
<dd>
If the sizes are inconsistent, the function will print an error message and exit the program. </dd></dl>

</div>
</div>
<a id="a68f066f21a116c30448ba2ef92101dcf" name="a68f066f21a116c30448ba2ef92101dcf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68f066f21a116c30448ba2ef92101dcf">&#9670;&#160;</a></span>h_l_rgb()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VectorXd h_l_rgb </td>
          <td>(</td>
          <td class="paramtype">const VectorXd &amp;&#160;</td>
          <td class="paramname"><em>ksi_pg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const long double&#160;</td>
          <td class="paramname"><em>factor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates the H(l)/H(l=0) ratio based on the given ksi_pg and a factor. </p>
<p>This function calculates the h_l_rgb vector by subtracting factor*ksi_pg from a vector of ones, and then taking the square root of each element. If any element in the resulting vector is smaller than a given tolerance, it is set to a value close to 0 at the machine precision level to avoid division by 0 or infinity.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ksi_pg</td><td>The ksi_pg vector. </td></tr>
    <tr><td class="paramname">factor</td><td>The factor value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The h_l_rgb vector. </dd></dl>

</div>
</div>
<a id="a8cf55c8478283af8616cd564787b4423" name="a8cf55c8478283af8616cd564787b4423"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8cf55c8478283af8616cd564787b4423">&#9670;&#160;</a></span>ksi_fct1()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VectorXd ksi_fct1 </td>
          <td>(</td>
          <td class="paramtype">const VectorXd &amp;&#160;</td>
          <td class="paramname"><em>nu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const long double&#160;</td>
          <td class="paramname"><em>nu_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const long double&#160;</td>
          <td class="paramname"><em>nu_g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const long double&#160;</td>
          <td class="paramname"><em>Dnu_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const long double&#160;</td>
          <td class="paramname"><em>DPl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const long double&#160;</td>
          <td class="paramname"><em>q</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates the ksi function as defined in equation 14 of Mosser+2017 (<a href="https://arxiv.org/pdf/1509.06193.pdf">https://arxiv.org/pdf/1509.06193.pdf</a>). </p>
<p>This function calculates the zeta function using the given parameters and equations.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nu</td><td>The frequency axis in microHz. </td></tr>
    <tr><td class="paramname">nu_p</td><td>The frequency of a p-mode in microHz. </td></tr>
    <tr><td class="paramname">nu_g</td><td>The frequency of a g-mode in microHz. </td></tr>
    <tr><td class="paramname">Dnu_p</td><td>The large separation, which can be a function of np or nu to account for glitches. </td></tr>
    <tr><td class="paramname">DPl</td><td>The period spacing in seconds. </td></tr>
    <tr><td class="paramname">q</td><td>The coupling term, without any unit. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The ksi vector which is the local zeta function. </dd></dl>

</div>
</div>
<a id="ac13e6fb329a8ab7731d252b7e8d57fcf" name="ac13e6fb329a8ab7731d252b7e8d57fcf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac13e6fb329a8ab7731d252b7e8d57fcf">&#9670;&#160;</a></span>ksi_fct2()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::VectorXd ksi_fct2 </td>
          <td>(</td>
          <td class="paramtype">const Eigen::VectorXd &amp;&#160;</td>
          <td class="paramname"><em>nu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::VectorXd &amp;&#160;</td>
          <td class="paramname"><em>nu_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::VectorXd &amp;&#160;</td>
          <td class="paramname"><em>nu_g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::VectorXd &amp;&#160;</td>
          <td class="paramname"><em>Dnu_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::VectorXd &amp;&#160;</td>
          <td class="paramname"><em>DPl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const long double&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>norm_method</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates the zeta function for mixed modes in precise mode. </p>
<p>This function calculates the ksi_pg vector using the ksi_fct1 function for each combination of nu_p and nu_g.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nu</td><td>The frequency vector. </td></tr>
    <tr><td class="paramname">nu_p</td><td>The list of p modes in a vector form. </td></tr>
    <tr><td class="paramname">nu_g</td><td>The list of g modes in a vector form. </td></tr>
    <tr><td class="paramname">Dnu_p</td><td>The local values of the large separation, through a vector. </td></tr>
    <tr><td class="paramname">DPl</td><td>The local values of the period spacing in the form of a vector. </td></tr>
    <tr><td class="paramname">q</td><td>The coupling strength q between p and g modes. </td></tr>
    <tr><td class="paramname">norm_method</td><td>The method for normalizing the ksi_pg vector. Possible values: "fast" or "exact". In the exact mode, the ksi_fct2_precise function is used. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The ksi_pg vector which is the zeta function intervening in mixed modes. </dd></dl>

</div>
</div>
<a id="a5b087f1888177533f5001c70745b5bdc" name="a5b087f1888177533f5001c70745b5bdc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b087f1888177533f5001c70745b5bdc">&#9670;&#160;</a></span>ksi_fct2_precise()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::VectorXd ksi_fct2_precise </td>
          <td>(</td>
          <td class="paramtype">const Eigen::VectorXd &amp;&#160;</td>
          <td class="paramname"><em>nu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::VectorXd &amp;&#160;</td>
          <td class="paramname"><em>nu_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::VectorXd &amp;&#160;</td>
          <td class="paramname"><em>nu_g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::VectorXd &amp;&#160;</td>
          <td class="paramname"><em>Dnu_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::VectorXd &amp;&#160;</td>
          <td class="paramname"><em>DPl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const long double&#160;</td>
          <td class="paramname"><em>q</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates the zeta function for mixed modes in precise mode. </p>
<p>This function calculates the ksi_pg vector using the ksi_fct1 function for each combination of nu_p and nu_g. It also performs parallel computation using OpenMP for better performance.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nu</td><td>The frequency vector. </td></tr>
    <tr><td class="paramname">nu_p</td><td>The list of p modes in a vector form. </td></tr>
    <tr><td class="paramname">nu_g</td><td>The list of g modes in a vector form. </td></tr>
    <tr><td class="paramname">Dnu_p</td><td>The local values of the large separation, through a vector. </td></tr>
    <tr><td class="paramname">DPl</td><td>The local values of the period spacing in the form of a vector. </td></tr>
    <tr><td class="paramname">q</td><td>The coupling strength q between p and g modes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The ksi_pg vector which is the zeta function intervening in mixed modes. </dd></dl>

</div>
</div>
<a id="aad899e3b2dcf1b28b9462239337a0462" name="aad899e3b2dcf1b28b9462239337a0462"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad899e3b2dcf1b28b9462239337a0462">&#9670;&#160;</a></span>make_synthetic_asymptotic_star()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_params__synthetic__star.html">Params_synthetic_star</a> make_synthetic_asymptotic_star </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_cfg__synthetic__star.html">Cfg_synthetic_star</a>&#160;</td>
          <td class="paramname"><em>cfg_star</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generates a set of mode parameters for simulating an evolved star based on the asymptotic relations. </p>
<p>This function generates a set of mode parameters for simulating an evolved star based on the asymptotic relations. The function takes a structure <code>cfg_star</code> as input, which contains all the important parameters for creating the mode parameters. The mode parameters include frequencies, widths, heights, and a-coefficients for each mode of degree l=0, l=1, l=2, and l=3.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cfg_star</td><td>A structure that contains all the important parameters for creating the mode parameters, such as (see cfg_star structure itself for the full list),<ul>
<li>Dnu_star: Large separation for the p modes.</li>
<li>epsilon_star: Phase offset term for the asymptotic relation of the p modes.</li>
<li>delta0l_star, alpha_p_star, nmax_star: Parameters for creating 2nd order asymptotic p modes.</li>
<li>DPl_star: Period spacing for l=1 g modes.</li>
<li>alpha_star: Phase offset term for the asymptotic relation of the g modes.</li>
<li>q_star: Coupling coefficient between p and g modes.</li>
<li>fmin: Minimum frequency for the modes that should be included in the calculations.</li>
<li>fmax: Maximum frequency for the modes that should be included in the calculations. </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A structure <code>params_out</code> that contains the mode parameters for simulating the evolved star.<ul>
<li>nu_lx: Frequencies of the l=x modes, where x is between 0 and 3.</li>
<li>nu_p_l1: Base p mode frequencies used to build the frequencies for the l=1 mixed modes.</li>
<li>nu_g_l1: Base g mode frequencies used to build the frequencies for the l=1 mixed modes.</li>
<li>width_lx: Widths of the l=x modes, where x is between 0 and 3.</li>
<li>height_lx: Heights of the l=x modes, where x is between 0 and 3.</li>
<li>aj_lx: The a-coefficients of order j for each mode of degree l=x. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a4550aabd598313869e70af350ca319bc" name="a4550aabd598313869e70af350ca319bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4550aabd598313869e70af350ca319bc">&#9670;&#160;</a></span>numax_from_stello2009()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long double numax_from_stello2009 </td>
          <td>(</td>
          <td class="paramtype">const long double&#160;</td>
          <td class="paramname"><em>Dnu_star</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const long double&#160;</td>
          <td class="paramname"><em>spread</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the value of numax based on the Dnu_star parameter using the relation from Stello+2009. </p>
<p>This function calculates the value of numax based on the Dnu_star parameter using the relation from Stello+2009. The relation is given by Dnu ~ 0.263 * numax^0.77. The function also allows for adding a uniform spread around numax if the spread parameter is provided.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Dnu_star</td><td>The Dnu_star parameter. </td></tr>
    <tr><td class="paramname">spread</td><td>The spread around numax, given as a fraction (e.g., 5% is 0.05). Default value is 0. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The value of numax. </dd></dl>

</div>
</div>
<a id="a7e0292785f729d13fe114ce0c8554129" name="a7e0292785f729d13fe114ce0c8554129"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e0292785f729d13fe114ce0c8554129">&#9670;&#160;</a></span>read_templatefile()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structtemplate__file.html">template_file</a> read_templatefile </td>
          <td>(</td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>ignore_errors</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads a template file and extracts relevant information. </p>
<p>This function reads a template file and extracts the ID reference, numax reference, Dnu reference, epsilon reference, and data reference from the file. The file should be formatted with key-value pairs separated by a delimiter. Comments in the header are ignored.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">file</td><td>The path to the template file. </td></tr>
    <tr><td class="paramname">ignore_errors</td><td>Flag indicating whether to ignore errors if the required keywords are not found in the file. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="structtemplate__file.html" title="Structure for simulations to derive height and widths of modes.">template_file</a> object containing the extracted information. </dd></dl>

</div>
</div>
<a id="a7fc7fa1e50e82ef213ac96c86a23dc59" name="a7fc7fa1e50e82ef213ac96c86a23dc59"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7fc7fa1e50e82ef213ac96c86a23dc59">&#9670;&#160;</a></span>rot_2zones_v2()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_data__rot2zone.html">Data_rot2zone</a> rot_2zones_v2 </td>
          <td>(</td>
          <td class="paramtype">const long double&#160;</td>
          <td class="paramname"><em>rot_envelope</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const long double&#160;</td>
          <td class="paramname"><em>core2envelope_star</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>output_file_rot</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the core rotation from the surface rotation. </p>
<p>This function computes the core rotation based on the given surface rotation and the average core-to-envelope ratio. It is used to achieve a uniform distribution of rotation in the envelope and a uniform population of core-to-envelope ratios.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rot_envelope</td><td>The average rotation in the envelope (in microHz). </td></tr>
    <tr><td class="paramname">core2envelope_star</td><td>The average rotation in the core. </td></tr>
    <tr><td class="paramname">output_file_rot</td><td>The path to the output file to save the computed rotation values. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="struct_data__rot2zone.html" title="Structure for rotation to zone data.">Data_rot2zone</a> object containing the computed rotation values. </dd></dl>

</div>
</div>
<a id="a37ce54feb9cd023be30b5e0f97f0bf88" name="a37ce54feb9cd023be30b5e0f97f0bf88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37ce54feb9cd023be30b5e0f97f0bf88">&#9670;&#160;</a></span>rot_2zones_v3()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_data__rot2zone.html">Data_rot2zone</a> rot_2zones_v3 </td>
          <td>(</td>
          <td class="paramtype">const long double&#160;</td>
          <td class="paramname"><em>rot_envelope</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const long double&#160;</td>
          <td class="paramname"><em>rot_core</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>output_file_rot</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the core rotation from the surface rotation. </p>
<p>This function computes the core rotation based on the given surface rotation and the average core-to-envelope ratio. It is used to achieve a uniform distribution of rotation in the envelope and a uniform population of core-to-envelope ratios.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rot_envelope</td><td>The average rotation in the envelope (in microHz). </td></tr>
    <tr><td class="paramname">rot_core</td><td>The average rotation in the core (in microHz). </td></tr>
    <tr><td class="paramname">output_file_rot</td><td>The path to the output file to save the computed rotation values. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="struct_data__rot2zone.html" title="Structure for rotation to zone data.">Data_rot2zone</a> object containing the computed rotation values. </dd></dl>

</div>
</div>
<a id="aab630af9de049c0647dfec3c1206a9ac" name="aab630af9de049c0647dfec3c1206a9ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab630af9de049c0647dfec3c1206a9ac">&#9670;&#160;</a></span>rot_envelope()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long double rot_envelope </td>
          <td>(</td>
          <td class="paramtype">long double&#160;</td>
          <td class="paramname"><em>med</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long double&#160;</td>
          <td class="paramname"><em>sigma</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the rotation in the envelope based on a truncated Gaussian distribution. </p>
<p>This function determines the rotation in the envelope based on a truncated Gaussian distribution. The distribution is inspired by the surface rotation from Ceillier et al. 2017 (<a href="https://arxiv.org/pdf/1707.05989.pdf">https://arxiv.org/pdf/1707.05989.pdf</a>), Fig. 5, which has a skewed distribution ranging from ~30 days to ~160 days with a peak around 60 days. For simplicity, a truncated Gaussian distribution is used with rotation values between 30 and 90 days and a median of 60 days. The truncation happens at sigma. The values are given in days.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">med</td><td>The median of the distribution (in days). </td></tr>
    <tr><td class="paramname">sigma</td><td>The standard deviation of the distribution (in days). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The rotation frequency in microHz. </dd></dl>

</div>
</div>
<a id="af39be32ef8277be6aed321eed67a4684" name="af39be32ef8277be6aed321eed67a4684"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af39be32ef8277be6aed321eed67a4684">&#9670;&#160;</a></span>width_height_load_rescale()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_data__2vect_xd.html">Data_2vectXd</a> width_height_load_rescale </td>
          <td>(</td>
          <td class="paramtype">const VectorXd &amp;&#160;</td>
          <td class="paramname"><em>nu_star</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const long double&#160;</td>
          <td class="paramname"><em>Dnu_star</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const long double&#160;</td>
          <td class="paramname"><em>numax_star</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>file</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Loads and rescales data from a file based on reference values. </p>
<p>This function loads data from a file and rescales it based on reference values. The rescaling is done using interpolation and the extracted information from the template file. The rescaled data is then returned as a <a class="el" href="struct_data__2vect_xd.html" title="Structure for holding two VectorXd objects.">Data_2vectXd</a> object.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nu_star</td><td>The reference frequencies. </td></tr>
    <tr><td class="paramname">Dnu_star</td><td>The reference Dnu value. </td></tr>
    <tr><td class="paramname">numax_star</td><td>The reference numax value. </td></tr>
    <tr><td class="paramname">file</td><td>The path to the template file. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="struct_data__2vect_xd.html" title="Structure for holding two VectorXd objects.">Data_2vectXd</a> object containing the rescaled data. </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
