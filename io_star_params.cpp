/*
 * write_star_params.cpp
 *
 * Contains all kind of methods
 * used to process and/or encapsulate data
 * 
 *  Created on: 22 Feb 2016
 *      Author: obenomar
 */
# include <iostream>
# include <iomanip>
#include <fstream>
# include <Eigen/Dense>
# include <vector>
#include <string>
#include "io_star_params.h"
#include "string_handler.h"
//#include "data.h"

using Eigen::VectorXd;
using Eigen::VectorXi;
using Eigen::MatrixXd;

void write_star_params_act_asym(VectorXd spec_params, MatrixXd mode_params, MatrixXd noise_params, std::string file_out, std::string identifier){

	VectorXi Nchars_spec(2), Nchars_params(11), Nchars_noise(3), precision_spec(2), precision_params(11), precision_noise(3);

	std::ofstream outfile;
	outfile.open(file_out.c_str());
    
    if(outfile.is_open()){
		// ---------------------
		Nchars_spec << 20, 20;
		precision_spec << 10, 10;

		outfile << "ID= " << identifier << std::endl;

		outfile << "# Spectrum parameters. Observation duration (days) / Cadence (seconds)" << std::endl;
		outfile << std::setw(Nchars_spec[0]) << std::setprecision(precision_spec[1]) << spec_params[0];
		outfile << std::setw(Nchars_spec[1]) << std::setprecision(precision_spec[1]) << spec_params[1] << std::endl;

		// ---------------------
		Nchars_params << 5, 20, 20, 20, 10, 16, 16, 16, 14, 16, 10;
		precision_params << 1, 10, 10, 10, 10, 8, 8, 8, 2, 8, 3;


		outfile << "# Configuration of mode parameters. This file was generated by write_star_mode_params_act_asym (write_star_params.cpp)" << std::endl;
		outfile << "# Input mode parameters. degree / freq / H / W / splitting a1 / eta / a3 /  b (mag) / alfa (mag) / asymetry / inclination" << std::endl;
		
		for(int i=0; i<mode_params.rows(); i++){
			for(int j=0;j<mode_params.cols(); j++){
				outfile << std::setw(Nchars_params[j]) << std::setprecision(precision_params[j]) << mode_params(i,j);
			}
			outfile << std::endl;
		}

		// ---------------------
		Nchars_noise << 16, 16, 16;
		precision_noise << 6, 6, 6;

		outfile << "# Configuration of noise parameters. This file was generated by write_star_mode_params (write_star_params.cpp)" << std::endl;
		outfile << "# Input mode parameters. H0 , tau_0 , p0 / H1, tau_1, p1 / N0. Set at -1 if not used. -2 means that the parameter is not even written on the file (because irrelevant)." << std::endl;

		for(int i=0; i<noise_params.rows(); i++){
			for(int j=0;j<noise_params.cols(); j++){
				outfile << std::setw(Nchars_noise[j]) << std::setprecision(precision_noise[j]) << noise_params(i,j);
			}
			outfile << std::endl;
		}
		outfile.close();
    }  
	else {
		std::cout << " Unable to open file " << file_out << std::endl;	
		std::cout << " Check that the full path exists" << std::endl;
		std::cout << " The program will exit now" << std::endl;
		exit(EXIT_FAILURE);
	}
}

void write_star_mode_params_a1a2a3(MatrixXd mode_params, std::string file_out){

	VectorXi Nchars(8), precision(8);

	std::ofstream outfile;

	Nchars << 5, 15, 15, 15, 10, 16, 16, 10;
	precision << 1, 2, 4, 4, 4, 8, 8, 3;

	outfile.open(file_out.c_str());
	if(outfile.is_open()){

		outfile << "# Configuration of mode parameters. This file was generated by write_star_mode_params (write_star_params.cpp)" << std::endl;
		outfile << "# Input mode parameters. degree / freq / H / W / splitting a1 / eta / a3 / inclination" << std::endl;
		
		for(int i=0; i<mode_params.rows(); i++){
			for(int j=0;j<mode_params.cols(); j++){
				outfile << std::setw(Nchars[j]) << std::setprecision(precision[j]) << mode_params(i,j);
			}
			outfile << std::endl;
		}
		outfile.close();
	}  
	else {
		std::cout << " Unable to open file " << file_out << std::endl;	
		std::cout << " Check that the full path exists" << std::endl;
		std::cout << " The program will exit now" << std::endl;
		exit(EXIT_FAILURE);
	}
	

}

void write_star_mode_params_act_asym(MatrixXd mode_params, std::string file_out){

	VectorXi Nchars(11), precision(11);

	std::ofstream outfile;

	Nchars << 5, 20, 15, 15, 10, 16, 16, 16, 14, 16, 10;
	precision << 1, 10, 4, 4, 4, 8, 8, 8, 2, 8, 3;

	outfile.open(file_out.c_str());
	if(outfile.is_open()){

		outfile << "# Configuration of mode parameters. This file was generated by write_star_mode_params_act_asym (write_star_params.cpp)" << std::endl;
		outfile << "# Input mode parameters. degree / freq / H / W / splitting a1 / eta / a3 /  b (mag) / alfa (mag) / asymetry / inclination" << std::endl;
		
		for(int i=0; i<mode_params.rows(); i++){
			for(int j=0;j<mode_params.cols(); j++){
				outfile << std::setw(Nchars[j]) << std::setprecision(precision[j]) << mode_params(i,j);
			}
			outfile << std::endl;
		}
		outfile.close();
	}  
	else {
		std::cout << " Unable to open file " << file_out << std::endl;	
		std::cout << " Check that the full path exists" << std::endl;
		std::cout << " The program will exit now" << std::endl;
		exit(EXIT_FAILURE);
	}
	
}


void write_star_noise_params(MatrixXd noise_params, std::string file_out){

	VectorXi Nchars(3), precision(3);

	std::ofstream outfile;

	Nchars << 16, 16, 16;
	precision << 6, 6, 6;

	outfile.open(file_out.c_str());
	if(outfile.is_open()){

		outfile << "# Configuration of mode parameters. This file was generated by write_star_mode_params (write_star_params.cpp)" << std::endl;
		outfile << "# Input mode parameters. H0 , tau_0 , p0 / H1, tau_1, p1 / N0. Set at -1 if not used. -2 means that the parameter is not even written on the file (because irrelevant)." << std::endl;
		
		for(int i=0; i<noise_params.rows(); i++){
			for(int j=0;j<noise_params.cols(); j++){
				outfile << std::setw(Nchars[j]) << std::setprecision(precision[j]) << noise_params(i,j);
			}
			outfile << std::endl;
		}
		outfile.close();
	}  
	else {
		std::cout << " Unable to open file " << file_out << std::endl;	
		std::cout << " Check that the full path exists" << std::endl;
		std::cout << " The program will exit now" << std::endl;
		exit(EXIT_FAILURE);
	}

}

void write_spectrum(VectorXd x, VectorXd y, VectorXd z, std::string file_out, bool write_inmodel){

	VectorXi Nchars(3), precision(3);

	std::ofstream outfile;

	Nchars << 20, 20, 20;
	precision << 10, 10, 7;

	outfile.open(file_out.c_str());
	if(outfile.is_open()){

        if(write_inmodel == 1){
            outfile << "#       freq (microHz)    spectrum (ppm2/microHz)   model spectrum (ppm2/microHz)" << std::endl;
        } else{
            outfile << "#       freq (microHz)    spectrum (ppm2/microHz)" << std::endl;
        }
        
		for(int i=0; i<x.size(); i++){
			outfile << std::setw(Nchars[0]) << std::setprecision(precision[0]) << x[i];
			outfile << std::setw(Nchars[1]) << std::setprecision(precision[1]) << y[i];
			if(write_inmodel == 1){
                outfile << std::setw(Nchars[2]) << std::setprecision(precision[2]) << z[i];
            }
			outfile << std::endl;
		}
		outfile.close();
	}  
	else {
		std::cout << " Unable to open file " << file_out << std::endl;	
		std::cout << " Check that the full path exists" << std::endl;
		std::cout << " The program will exit now" << std::endl;
		exit(EXIT_FAILURE);
	}

}

void write_spectrum_v2(const VectorXd x, const VectorXd y, const VectorXd z, const double scoef1, double scoef2, const std::string file_out){
/* 
 * Same as write_spectrum, but we add two columns with values for the smooth of the vector y using a boxcar
 * With a smooth coeficient scoef1 (column 2) or scoef2 (column 3).
 *
*/
	VectorXi Nchars(3), precision(3);
	VectorXd ys1, ys2;

	std::ofstream outfile;

    //std::cout << " - write_spectrum_v2..." << std::endl;

	Nchars << 20, 20, 20;
	precision << 10, 10, 7;

    //std::cout << " - scoef1:" << scoef1 << std::endl;
	ys1=smooth(y, scoef1);
    //if(scoef1 == scoef2){ scoef2=1.5*scoef1;}
    //std::cout << " - scoef2:" << scoef2 << std::endl;
	ys2=smooth(y, scoef2);

    //std::cout << " - Writing spectrum info..." << std::endl;
	outfile.open(file_out.c_str());
	if(outfile.is_open()){

		outfile << "#       freq (microHz)    spectrum (ppm2/microHz)   smooth spectrum (scoef1)    smooth spectrum (scoef2)    model spectrum (ppm2/microHz)" << std::endl;
		
		for(int i=0; i<x.size(); i++){
			outfile << std::setw(Nchars[0]) << std::setprecision(precision[0]) << x[i];
			outfile << std::setw(Nchars[1]) << std::setprecision(precision[1]) << y[i];
			outfile << std::setw(Nchars[1]) << std::setprecision(precision[1]) << ys1[i];
			outfile << std::setw(Nchars[1]) << std::setprecision(precision[1]) << ys2[i];
			outfile << std::setw(Nchars[2]) << std::setprecision(precision[2]) << z[i];
			outfile << std::endl;
		}
		outfile.close();
        //std::cout << " - Done." << std::endl;

    }
	else {
		std::cout << " Unable to open file " << file_out << std::endl;	
		std::cout << " Check that the full path exists" << std::endl;
		std::cout << " The program will exit now" << std::endl;
		exit(EXIT_FAILURE);
	}

}

VectorXd smooth(const VectorXd in, const double scoef){
/* 
 * Return a boxcar smooth of a vector. The smooth coeficient
 * is in natural unit of the vector (ie, microHz not in bins)
*/

  VectorXd out(in.size());
  const double dx=std::abs(in[1]-in[0]);
  double Nbins_d=scoef/dx;
  int Nbins=floor(Nbins_d);
  //Nbins_d=scoef/dx;
  //Nbins=int(Nbins_d);

  if(Nbins >= in.size()/3){
      Nbins=in.size()/6;
  }
  if(Nbins > 1){
  	if(Nbins%2 != 0){Nbins=Nbins +1;} // ensure that the Nbins/2 is an integer
      //std::cout << "[1] Nbins_d=" << Nbins_d << "    Nbins=" << Nbins << "    dx=" << dx << "     in.size()=" << out.size() << std::endl;

 	 //std::cout << "Nbins_d=" << Nbins_d << std::endl;
  	 //std::cout << "Nbins=" << Nbins << std::endl;
 	 for (int i=Nbins; i<in.size()-Nbins; i++){
		out[i]=in.segment(i- Nbins/2, Nbins).sum()/Nbins; // Centered average
	  }
	  //std::cout << " - Passed loop 1" << std::endl;
	  for (int i=0; i<Nbins; i++){
          //std::cout << "i= " << i << "   i+Nbins/2 =" << i+Nbins/2;
		  out[i]=in.segment(0, i+Nbins/2).sum()/(i+Nbins/2); // Right side average
          //std::cout << "    passed " << std::endl;
	  }
	  //std::cout << " - Passed loop 2" << std::endl;
	  for (int i=in.size()-1-Nbins; i<in.size(); i++){
		out[i]=in.segment(i-Nbins/2, in.size()-1-i).sum()/(in.size()-1-i); // Left side average
		//std::cout << "out[" << i << "]=" << out[i];
	  }
	  //std::cout << " - Passed loop 3" << std::endl;
  } else {
	out=in;
  }

return out;
}


Star_params read_star_params(const std::string file_in_name){

    const int data_Maxsize=1000; 

	bool verbose_data=1, passed=0;
	int Nrows, cpt;
	long double tmp_val;
    std::ifstream file_in;
    std::vector<std::string> data_str;
    std::string line0, subline0;

	Star_params params;

	file_in.open(file_in_name.c_str());
    if (file_in.is_open()) {
		if (verbose_data == 1) {std::cout << "Reference file " << file_in_name << " opened... processing..." << std::endl;}

		// [1] Get the ID
		cpt=0;
		std::getline(file_in, line0);
		line0=strtrim(line0); // remove any white space at the begining/end of the string
		subline0=strtrim(line0.substr(0, 1)); // pick the first character
		subline0=subline0.c_str();
		passed=0;
		while(subline0 == "#"){	
				std::getline(file_in, line0);
				line0=strtrim(line0); // remove any white space at the begining/end of the string
				subline0=strtrim(line0.substr(0, 1)); // pick the first character
				subline0=subline0.c_str();		
				cpt=cpt+1;
				passed=1;
		}
		if (passed ==0){
			std::cout << "   [1] First comment line(s) not found. Beware that this is really a .in file! Attempting to pursuing operations..." << std::endl;
		}
		data_str=strsplit(line0, " ");
		if (data_str.size() == 1){
			params.identifier=strtrim(line0); // After header comments, we must have the ID
			if(verbose_data == 1){ std::cout << "Identifier : " << params.identifier << std::endl;}
		} else{
			std::cout << "Incorrect format for the Identifier! " << std::endl;
			std::cout << "The identifier should appear in a single line and must not contain spaces" << std::endl;
			std::cout << "The program will exit now" << std::endl;
			exit(EXIT_FAILURE);
		}
		// [2] Get the observation duration and the cadence (if any)
		std::getline(file_in, line0);
		line0=strtrim(line0); // remove any white space at the begining/end of the string
		subline0=strtrim(line0.substr(0, 1)); // pick the first character
		subline0=subline0.c_str();
		passed=0;
		while(subline0 == "#"){		
				std::getline(file_in, line0);
				line0=strtrim(line0); // remove any white space at the begining/end of the string
				subline0=strtrim(line0.substr(0, 1)); // pick the first character
				subline0=subline0.c_str();		
				cpt=cpt+1;
				passed=1;
		}
		if (passed == 0){
			std::cout << "   [2] Second group of comments line(s) not found. Beware that this is really a .in file! Attempting to pursuing operations..." << std::endl;
		}
		data_str=strsplit(line0, " ");
		if (data_str.size() == 2){ // After the second group of comments, we might have the the observation duration and the cadence
			params.Tobs=str_to_dbl(strtrim(data_str[0])); 
			params.cadence=str_to_dbl(strtrim(data_str[1]));
			if (verbose_data == 1){
				std::cout << "    [2] Found Tobs and Cadence information..." << std::endl;
				std::cout << "  Tobs = " << params.Tobs << std::endl;
				std::cout << "  Cadence = " << params.cadence << std::endl;
			}
		} else{ // Otherwise, it must be the mode parameters. We warn the user about the anomalous file, but attempt to continue to read the rest
			std::cout << "Warning: Could not find the line corresponding to the observation and cadence!" << std::endl;
			std::cout << "         It should be a line with two entries only, separated by spaces." << std::endl;
			std::cout << "         The file may not be a proper in file... please check..." << std::endl;
			std::cout << "         Setting Tobs = -1 and Cadence = -1" << std::endl;
			std::cout << "         Attempting to pursue, assuming that what follows is the matrix of mode parameters..." << std::endl;
		}

		// [3] Read the mode parameters...
		if (verbose_data == 1) {std::cout <<  "   [3] Now processing the mode parameters..." << std::endl;}
		
		std::getline(file_in, line0);
		line0=strtrim(line0); // remove any white space at the begining/end of the string
		subline0=strtrim(line0.substr(0, 1)); // pick the first character
		subline0=subline0.c_str();
		passed=0;
		while(subline0 == "#"){		
				std::getline(file_in, line0);
				line0=strtrim(line0); // remove any white space at the begining/end of the string
				subline0=strtrim(line0.substr(0, 1)); // pick the first character
				subline0=subline0.c_str();		
				cpt=cpt+1;
				passed=1;
		}
		Nrows=0;
		subline0=" ";
	    while(!file_in.eof() && subline0 != "#"){
			data_str=strsplit(strtrim(line0), " \t"); 
			if (Nrows == 0) {
				params.mode_params.resize(data_Maxsize, data_str.size());
				params.mode_params.setConstant(-1);
			}
			for(int i=0; i<data_str.size();i++){
				if ( ! (std::istringstream(data_str[i]) >> tmp_val) ){tmp_val = nan("");} // If the number can be converted, then tmp_val=value. Otherwise tmp_val = NaN
				params.mode_params(Nrows, i)=tmp_val;		
			}
			if (verbose_data == 1) {std::cout << params.mode_params.row(Nrows) << std::endl;} // Show all entries only if requested
			std::getline(file_in, line0);
			line0=strtrim(line0); // remove any white space at the begining/end of the string
			subline0=strtrim(line0.substr(0, 1)); // pick the first character
			subline0=subline0.c_str();
			Nrows=Nrows+1;
	    }		
	    params.mode_params.conservativeResize(Nrows, params.mode_params.cols());
		if (verbose_data == 1) {
			std::cout << "         - Number of modes found: " << Nrows << std::endl;
			std::cout << "         - Number of mode parameters found: " << params.mode_params.cols() << std::endl;
		}
	    if(subline0 == "#"){ // After all mode parameters, we must have a comment line to anounce the section with noise parameters
			std::getline(file_in, line0);
			Nrows=0;
			subline0=" ";
			if (verbose_data == 1) {std::cout <<  "   [4] Now processing the noise parameters..." << std::endl;}
	    	while(!file_in.eof()){
				data_str=strsplit(strtrim(line0), " \t"); 
				if (Nrows == 0) {
					params.noise_params.resize(data_Maxsize, data_str.size());
					params.noise_params.setConstant(-2);
				}
				for(int i=0; i<data_str.size();i++){
					if ( ! (std::istringstream(data_str[i]) >> tmp_val) ){tmp_val = nan("");} // If the number can be converted, then tmp_val=value. Otherwise tmp_val = NaN
					params.noise_params(Nrows, i)=tmp_val;		
				}
				if (verbose_data == 1) {std::cout << params.noise_params.row(Nrows) << std::endl;} // Show all entries only if requested
				std::getline(file_in, line0);
				Nrows=Nrows+1;
		    }
			data_str=strsplit(strtrim(line0), " \t"); 
			for(int i=0; i<data_str.size();i++){
				if ( ! (std::istringstream(data_str[i]) >> tmp_val) ){tmp_val = nan("");} // If the number can be converted, then tmp_val=value. Otherwise tmp_val = NaN
				params.noise_params(Nrows, i)=tmp_val;		
			}
			Nrows=Nrows+1;
			if (verbose_data == 1) {std::cout << params.noise_params.row(Nrows) << std::endl;} // Show all entries only if requested
		    params.noise_params.conservativeResize(Nrows, params.noise_params.cols());
		if (verbose_data == 1) {
			std::cout << "         - Number of lines for noise parameters found: " << Nrows+1 << std::endl;
			std::cout << "         - Number of columns for noise parameters found: " << params.noise_params.cols() << std::endl;
		}
	    } else{ // If this is not the case, then there is something wrong and we have to stop the program
	    	std::cout << "Error:  Could not find the section with noise parameters" << std::endl;
	    	std::cout << "        The code looks for a comment line following the section for mode parameters, but could not find it" << std::endl;
	    	std::cout << "        Cannot pursue. The program will exit now" << std::endl;
	    	exit(EXIT_FAILURE);
	    }

	file_in.close();
	
    } else {
 		if (verbose_data == 1) {std::cout << "Reference file " << file_in_name << std::endl;}
		std::cout << "Could not open the in file!" << std::endl;
		std::cout << "use the full path of the file in order to read it without issue " << std::endl;
		exit(EXIT_FAILURE);
    }

	return params;
}

Data_Nd read_data_ascii_Ncols(const std::string file_in_name, const std::string delimiter, const bool verbose_data){
/*
 * This function read an input file (file_in_name) which may or may not contain a header, labels, units indicator.
 * The number of column can be as small as 1
*/

    int cpt, Nrows;
    std::string line, line0, subline0; //token
    std::vector<std::string> header, labels, units, data_str;
    long double tmp_val;
    MatrixXd data;
    Data_Nd all_data_out; // The structure that encapsulate all the data, the header, the labels and units
    const int data_Maxsize=1000000; 
    std::ifstream file_in;
    if (verbose_data == 1) {
 	   std::cout << "  Assumptions for the data file: " << std::endl;
 	   std::cout << "       - header lines appear on the top of the file and are indicated by a # for first character. The header is however optional (then no # are found)" << std::endl;
 	   std::cout << "       - labels appear in one single line that is just after the  header and is indicated by a ! for first character. Labels are optional (then no ! are found)" << std::endl;
 	   std::cout << "       - units appear in one single line that is just after the  labels or the header (if the labels are missing) and is indicated by a * for first character. Units are optional (then no * are found)" << std::endl;
 	   std::cout << "       - Maximum number of lines for the data: " << data_Maxsize << std::endl;
	}
    file_in.open(file_in_name.c_str());
    if (file_in.is_open()) {
	if (verbose_data == 1) {std::cout << "Data File opened... processing lines" << std::endl;}

		// [1] Get the header
		cpt=0;
		std::getline(file_in, line0);
		line0=strtrim(line0); // remove any white space at the begining/end of the string
		subline0=strtrim(line0.substr(0, 1)); // pick the first character
		subline0=subline0.c_str();
		if (subline0 == "#"){
			while(subline0 == "#"){		
				header.push_back(strtrim(line0.substr(1, std::string::npos))); // add all characters except the first one (and any space at the begining)

				std::getline(file_in, line0);
				line0=strtrim(line0); // remove any white space at the begining/end of the string
				subline0=strtrim(line0.substr(0, 1)); // pick the first character
				subline0=subline0.c_str();
				
				cpt=cpt+1;
			}
			if (verbose_data == 1) {std::cout << "   [1] " << cpt << " header lines found..." << std::endl;}
		} else{
			header.push_back("");
			if (verbose_data == 1) {std::cout << "   [1] Header not found. Header vector set to a blank vector<string> of size 1. Pursuing operations..." << std::endl;}
		}

		// [2] Read the labels... these are expected just after the header... If not found, then labels is left blank of size 1
		// No need to read line... already read by the previous loop
		line0=strtrim(line0); // remove any white space at the begining/end of the string
		subline0=strtrim(line0.substr(0, 1)); // pick the first character
		subline0=subline0.c_str();
		if(subline0 == "!"){
			
			labels=strsplit(strtrim(line0.substr(1,std::string::npos)), " \t"); // remove either when you found a white space or a tabulation
			if (verbose_data == 1) {std::cout << "   [2] " << labels.size() << " labels found..." << std::endl;}

			for(int i=0; i<labels.size();i++){
				labels[i]=strtrim(labels[i]); // remove spaces at begining/end of each substring
				if (verbose_data == 1) {std::cout << "         - " << labels[i] << std::endl;}
			}

		} else {
			labels.push_back("");
			if (verbose_data == 1) {std::cout << "   [2] No labels found. Label vector set to a blank vector<string> of size 1. Pursuing operations..." << std::endl;}
		}
		
		// [3] Read the units... these are expected just after the labels... If not found, then units is left blank of size 1
		// Read a new line only if we found a label. Otherwise, it is not necessary...
		if (labels[0] != ""){std::getline(file_in, line0);}
		line0=strtrim(line0); 
		subline0=strtrim(line0.substr(0, 1)); 
		subline0=subline0.c_str();
		if(subline0 == "*"){
			units=strsplit(strtrim(line0.substr(1,std::string::npos)), " \t"); 
			if (verbose_data == 1) {std::cout << "   [3] " << units.size() << " units found..." << std::endl;}
			for(int i=0; i<units.size();i++){
				units[i]=strtrim(units[i]);
				if (verbose_data == 1) {std::cout << "         - " << units[i] << std::endl;}
			}
		} else {
			units.push_back("");
			if (verbose_data == 1) {std::cout << "   [3] No units found. Units vector set to a blank vector<string> of size 1." << std::endl;}
		}

		// [4] Read the data...
		if (verbose_data == 1) {std::cout <<  "   [4] Now processing the data..." << std::endl;}
		if (labels[0] != "" || units[0] != ""){  // case where we need to read a new line before looping
			std::getline(file_in, line0);
		} 
		Nrows=0;
	   while(!file_in.eof()){
		data_str=strsplit(strtrim(line0), " \t"); 
		if (Nrows == 0) {
			data.resize(data_Maxsize, data_str.size());
			data.setConstant(-2);
		}
		for(int i=0; i<data_str.size();i++){
			if ( ! (std::istringstream(data_str[i]) >> tmp_val) ){tmp_val = nan("");} // If the number can be converted, then tmp_val=value. Otherwise tmp_val = NaN
			data(Nrows, i)=tmp_val;		
		}
		if (verbose_data == 1) {std::cout << data.row(Nrows) << std::endl;} // Show all entries only if requested
		std::getline(file_in, line0);
		Nrows=Nrows+1;
	    }
	file_in.close();
	data.conservativeResize(Nrows, data.cols());
	if (verbose_data == 1) {
		std::cout << "         - Number of lines found: " << Nrows << std::endl;
		std::cout << "         - Number of columns found: " << data.cols() << std::endl;
	}
     } else {
	std::cout << "Could not open the data file!" << std::endl;
	std::cout << "use the full path of the file in order to read it without issue " << std::endl;
	exit(EXIT_FAILURE);
     }

     all_data_out.data=data;
     all_data_out.header=header;
     all_data_out.labels=labels;
     all_data_out.units=units;

return all_data_out;
}


//std::string strtrim(const std::string& str){
/*
 * Small function that remove white space at the end and at
 * the begining of a string. 
 * The original program was taken from http://stackoverflow.com/questions/1798112/removing-leading-and-trailing-spaces-from-a-string
 * Modified in order to not use the C++11 standard:
 *  	- const auto --> const string
 *      - optional argument for the separator is now hardcoded
*/
 /*   std::string whitespace = " \t";
    size_t strBegin = str.find_first_not_of(whitespace);
    if (strBegin == std::string::npos)
        return ""; // no content

    size_t strEnd = str.find_last_not_of(whitespace);
    size_t strRange = strEnd - strBegin + 1;

    return str.substr(strBegin, strRange);
}
*/

// WARNING: THIS STRSPLIT2 IN STRING_HANDLER
//std::vector<std::string> strsplit(const std::string str, const std::string delimiters){
/*
 * Take a string and split it each time one of the listed delimiters is detected
*/
/*	std::string str0=strtrim(str);
	size_t pos=0;
	std::vector<std::string> str_splitted;

	while ((pos = str0.find_first_of(delimiters)) != std::string::npos) {
		    
		str_splitted.push_back(str0.substr(0, pos)); // get the substring
		str0.erase(0, pos + delimiters.length());
		//if(pos + delimiters.length() <= 1){
		//	str0.erase(0, pos + delimiters.length());
		//} else{
		//	str0.erase(0, pos + delimiters.length()-1);
		//}
		//
		str0=strtrim(str0); // remove any extra white space at the begining before iterating
	}
	str_splitted.push_back(str0); // do not forget to add the end of the string

return str_splitted;
}
*/

std::string rem_comments(std::string str0, std::string terminator){
/*
 * Simple command that remove anything after the terminatior (terminator included)
 * The command also remove blanks at the begining/end of the input string
 * Useful to remove comments
*/
	
	size_t pos;
	std::string str_out;
	
	pos = str0.find_first_of(terminator); // detect the end of the line
	if(pos != std::string::npos){	
		str_out=str0.substr(0, pos); // remove comments
		str_out=strtrim(str_out); // remove blanks
	} else {
		str_out=strtrim(str0); // remove blanks
	}

	return str_out;
}

/*bool str_to_bool(const std::string str){

	bool bool_out;

	std::stringstream(strtrim(str)) >> bool_out;
return bool_out;
}
*/

//std::vector<double> str_to_arrdbl(const std::string str, const std::string delimiters){
	/* 
	 * Used to extract arrays of values from a string. 
	 * The terminator indicates the symbol that indicate the end of a line (beyond it is comments)
	 * The delimiter indicates how the values are separated (e.g. with a "," or with " ")
	*/
/*	std::string str0;
	std::vector<std::string> vals_strs;
	std::vector<double> dbl_out;

	str0=strtrim(str); // remove blanks and convert to a stream

	vals_strs=strsplit(str0, delimiters); // get all values in a string
	
	dbl_out.resize(vals_strs.size());
	for (int i=0; i<vals_strs.size(); i++){
		std::stringstream(vals_strs[i]) >> dbl_out[i];
	}

	return dbl_out;
}
*/

//std::vector<double> arrstr_to_arrdbl(const std::vector<std::string> vals_strs){
	/* 
	 * Used to extract arrays of values from a string. 
	 * The terminator indicates the symbol that indicate the end of a line (beyond it is comments)
	 * The delimiter indicates how the values are separated (e.g. with a "," or with " ")
	*/

/*	std::vector<double> dbl_out;

	dbl_out.resize(vals_strs.size());
	for (int i=0; i<vals_strs.size(); i++){
		std::stringstream(vals_strs[i]) >> dbl_out[i];
	}

	return dbl_out;
}
*/

/*double str_to_dbl(const std::string str){

	double dbl_out;

	std::stringstream(strtrim(str)) >> dbl_out;
return dbl_out;
}

long str_to_lng(const std::string str){

	long lng_out;

	std::stringstream(strtrim(str)) >> lng_out;
return lng_out;
}
*/

Config_Data read_main_cfg(std::string cfg_file){

	int cpt, cptmax;
	std::string line0, subline0, tmp_str;
	std::vector<std::string> tmp_vec_str;
	std::ifstream file_in;
	std::vector<double> tmp;
	Config_Data cfg;

	
	cptmax=10; //maximum number of header lines
    	file_in.open(cfg_file.c_str());
    	if (file_in.is_open()) {
		std::cout << "Data File opened... processing lines" << std::endl;

		// [1] Ignore the header
		cpt=0;
		std::getline(file_in, line0);
		line0=strtrim(line0); // remove any white space at the begining/end of the string
		subline0=strtrim(line0.substr(0, 1)); // pick the first character
		subline0=subline0.c_str();
		while(subline0 == "#" && !file_in.eof() && cpt < cptmax){
			std::getline(file_in, line0);
			line0=strtrim(line0); // remove any white space at the begining/end of the string
			subline0=strtrim(line0.substr(0, 1)); // pick the first character
			subline0=subline0.c_str();
			cpt=cpt+1;
		}
		if(cpt > cptmax){
			std::cout << "Only comments were found on the file!" << std::endl;
			std::cout << "Maximum authorized comment lines: " << cptmax << std::endl;
			std::cout << "Debug required" <<std::endl;
			std::cout << "The program will exit now" << std::endl;
			exit(EXIT_FAILURE);
		}
		// [2] Get relevant data
		
			tmp_vec_str=strsplit(rem_comments(line0, "#"), " "); // split the line into segments of strings
			cfg.forest_type=tmp_vec_str[0]; // Get the keyword
			tmp_vec_str.erase(tmp_vec_str.begin()); // Remove the keyword before processing the parameters of the given keyword
			if(tmp_vec_str.size() >= 1) {
				cfg.forest_params=arrstr_to_arrdbl(tmp_vec_str);
			}

			std::getline(file_in, line0);
			tmp_vec_str=strsplit(rem_comments(line0, "#"), " ");
			cfg.model_name=tmp_vec_str[0];
			if(tmp_vec_str.size() > 1){
				for(int i=1; i<tmp_vec_str.size();i++){
					cfg.extra_params = cfg.extra_params +  strtrim(tmp_vec_str[i]) + " ";
				}
			}
			cfg.extra_params=strtrim(cfg.extra_params);

			std::getline(file_in, line0);
			cfg.labels=strsplit(rem_comments(line0, "#"), " ");

			std::getline(file_in, line0);
			cfg.val_min=str_to_arrdbl(rem_comments(line0, "#"), " ");

			std::getline(file_in, line0);
			cfg.val_max=str_to_arrdbl(rem_comments(line0, "#"), " ");

			std::getline(file_in, line0);
			cfg.step=str_to_arrdbl(rem_comments(line0, "#"), " ");

			std::getline(file_in, line0); // skip the labels of Tobs and Cadence

			std::getline(file_in, line0);
			//std::cout << "line0 = " << line0 << std::endl;
			//std::cout << "rem_comments(line0, '#') = " << rem_comments(line0, "#") << std::endl;
			tmp=str_to_arrdbl(rem_comments(line0, "#"), " ");
			cfg.Tobs=tmp[0];
			cfg.Cadence=tmp[1];	
            cfg.Nspectra=tmp[2];
            
			std::getline(file_in, line0);		
			cfg.erase_old_files=str_to_bool(rem_comments(line0, "#"));

            std::getline(file_in, line0);
            cfg.doplots=str_to_bool(rem_comments(line0, "#"));

            std::getline(file_in, line0);
            cfg.write_inmodel=str_to_bool(rem_comments(line0, "#"));


			file_in.close();
	} else {
		std::cout << "Could not open the configuration file!" << std::endl;
		std::cout << "Configuration file: " << cfg_file << std::endl;
		exit(EXIT_FAILURE);

	}
	

	if(cfg.step.size() != cfg.val_min.size() && cfg.step.size() != cfg.val_max.size()){
		std::cout << "The configuration file contains input vectors (val_min, val_max, step) of different size" << std::endl;
		std::cout << "The input vectors must gave the same size!" << std::endl;
		std::cout << "Please check your configuration file" << std::endl;
		std::cout << "The program will stop now" << std::endl;
		std::cout << "cfg.step.size()=" <<  cfg.step.size() << std::endl;
		std::cout << "cfg.val_min.size()=" << cfg.val_min.size() << std::endl;
		std::cout << "cfg.val_max.size()=" << cfg.val_max.size() << std::endl;
		exit(EXIT_FAILURE);
	}


	// ------- Verbose setup ------
	std::cout << "   cfg.model_name = ";
	std::cout << cfg.model_name << std::endl;

	std::cout << "   cfg.forest_type = " << cfg.forest_type << std::endl;
	std::cout << "   cfg.forest_params = ";
	for(int i=0; i<cfg.forest_params.size(); i++){
		std::cout << cfg.forest_params[i] << "  ";
	}
	std::cout << std::endl;

	std::cout << "   cfg.labels  = ";
	for(int i=0; i<cfg.labels.size(); i++){
		std::cout << std::setw(4) << cfg.labels[i] << "  ";
	}
	std::cout << std::endl;
	std::cout << "   cfg.val_min = ";
	for(int i=0; i<cfg.val_min.size(); i++){
		std::cout << std::setw(4) << cfg.val_min[i] << "  ";
	}
	std::cout << std::endl;
	std::cout << "   cfg.val_max = ";
	for(int i=0; i<cfg.val_max.size(); i++){
		std::cout << std::setw(4) << cfg.val_max[i] << "  ";
	}
	std::cout << std::endl;
	std::cout << "   cfg.step    = ";
	for(int i=0; i<cfg.step.size(); i++){
		std::cout << std::setw(4) << cfg.step[i] << "  ";
	}
	std::cout << std::endl;

	std::cout << "   cfg.Tobs = " << cfg.Tobs << std::endl;
	std::cout << "   cfg.Cadence = " << cfg.Cadence << std::endl;
	std::cout << "   cfg.erase_old_files = " << cfg.erase_old_files << std::endl;
	// -------------------

	return cfg;
}

bool file_exists(const std::string& name) {
    return ( access( name.c_str(), F_OK ) != -1 );
}

/*
// Small test program
int main(){

	int N=100;

	MatrixXd mode_params1(2, 8);
	MatrixXd mode_params2(3, 11);
	MatrixXd noise_params(3, 3);
	VectorXd x(N),y(N),z(N), spec_params(2);

	std::string identifier;
	std::string file_out1, file_out2, file_out3, file_out4, file_out5;

	file_out1="output_test1.txt";
	std::cout << "Test of write_star_mode_params_a1a2a3...outputs in " << file_out1 <<  std::endl;
	mode_params1.setRandom();
	
	for(int i=0; i<mode_params1.rows(); i++){
		for(int j=0; j<mode_params1.cols(); j++){
			std::cout << std::setw(10) << std::setprecision(5) << mode_params1(i,j);
		}
		std::cout << std::endl;
	}
	write_star_mode_params_a1a2a3(mode_params1, file_out1);
	std::cout << "--------------" << std::endl;




	file_out2="output_test2.txt";
	std::cout << "Test of write_star_mode_params_act_asym...outputs in " << file_out2 << std::endl;

	mode_params2.setRandom();	

	for(int i=0; i<mode_params2.rows(); i++){
		for(int j=0; j<mode_params2.cols(); j++){
			std::cout << std::setw(10) << std::setprecision(5) << mode_params2(i,j);
		}
		std::cout << std::endl;
	}
	write_star_mode_params_act_asym(mode_params2, file_out2);
	std::cout << "--------------" << std::endl;




	noise_params.setRandom();
	
	file_out3="output_test3.txt";
	std::cout << "Test of write_star_noise_params... outputs in " << file_out3 << std::endl;

	for(int i=0; i<noise_params.rows(); i++){
		for(int j=0; j<noise_params.cols(); j++){
			std::cout << std::setw(10) << std::setprecision(5) << noise_params(i,j);
		}
		std::cout << std::endl;
	}
	write_star_noise_params(noise_params, file_out3);
	std::cout << "--------------" << std::endl;

	file_out4="output_test4.txt";
	std::cout << "Test of write_spectrum...outputs in " << file_out4  << std::endl;

	x.setLinSpaced(0,1000);
	y.setRandom();
	z.setConstant(5);
	
	write_spectrum(x, y, z, file_out4);

	std::cout << "--------------" << std::endl;

	file_out5="output_test5.txt";
	std::cout << "Test of write_star_params_act_asym...outputs in " << file_out5  << std::endl;

	spec_params[0]=10;
	spec_params[1]=50;

	identifier="01234567";
	write_star_params_act_asym(spec_params, mode_params2, noise_params, file_out5, identifier);

}
*/
