/*
 * write_star_params.cpp
 *
 * Contains all kind of methods
 * used to process and/or encapsulate data
 * 
 *  Created on: 22 Feb 2016
 *      Author: obenomar
 */
# include <iostream>
# include <iomanip>
#include <fstream>
# include <Eigen/Dense>
# include <vector>
#include <string>
#include "io_star_params.h"
#include "io_star_common.h"
//#include "string_handler.h" // Replaced by ioproc.h on 17/06/2021
#include "ioproc.h"
#include "linfit.h"
# include "ioproc.h"
#include "linspace.h"

using Eigen::VectorXd;
using Eigen::VectorXi;
using Eigen::MatrixXd;


void write_star_params_Alm(VectorXd spec_params, MatrixXd mode_params, MatrixXd noise_params, std::string file_out, std::string identifier){
	write_global_info(spec_params, file_out, identifier, false);
	write_star_mode_params_Alm(mode_params, file_out, true);
	write_star_noise_params(noise_params, file_out, true);
}

void write_star_params_aj(VectorXd spec_params, MatrixXd mode_params, MatrixXd noise_params, std::string file_out, std::string identifier){
	write_global_info(spec_params, file_out, identifier, false);
	write_star_mode_params_aj(mode_params, file_out, true);
	write_star_noise_params(noise_params, file_out, true);
}

void write_star_params_act_asym(VectorXd spec_params, MatrixXd mode_params, MatrixXd noise_params, std::string file_out, std::string identifier){
	write_global_info(spec_params, file_out, identifier, false);
	write_star_mode_params_act_asym(mode_params, file_out, true);
	write_star_noise_params(noise_params, file_out, true);
}

void write_star_params_a1a2a3asym(VectorXd spec_params, MatrixXd mode_params, MatrixXd noise_params, std::string file_out, std::string identifier){
	std::cout << "OBSELETE MODEL: Please use write_star_params_aj instead" << std::endl;
	exit(EXIT_SUCCESS);
}


void write_star_mode_params_a1a2a3(MatrixXd mode_params, std::string file_out){
	std::cout << "OBSELETE MODEL: Please use write_star_params_aj instead" << std::endl;
	exit(EXIT_SUCCESS);
}



void write_star_mode_params_act_asym(MatrixXd mode_params, std::string file_out, bool append){

	VectorXi Nchars(11), precision(11);

	std::ofstream outfile;

	Nchars << 5, 20, 15, 15, 10, 16, 16, 16, 14, 16, 10;
	precision << 1, 10, 4, 4, 4, 8, 8, 8, 2, 8, 3;

	if(append == false){
		outfile.open(file_out.c_str());	
	} else{
		outfile.open(file_out.c_str(), std::ios::app);	
	}
	if(outfile.is_open()){

		outfile << "# Configuration of mode parameters. This file was generated by write_star_mode_params_act_asym (write_star_params.cpp)" << std::endl;
		outfile << "# Input mode parameters. degree / freq / H / W / splitting a1 / eta / a3 /  b (mag) / alfa (mag) / asymetry / inclination" << std::endl;
		
		for(int i=0; i<mode_params.rows(); i++){
			for(int j=0;j<mode_params.cols(); j++){
				outfile << std::setw(Nchars[j]) << std::setprecision(precision[j]) << mode_params(i,j);
			}
			outfile << std::endl;
		}
		outfile.close();
	}  
	else {
		file_read_error(file_out);
	}
	
}

void write_star_mode_params_Alm(MatrixXd mode_params, std::string file_out, bool append){

	VectorXi Nchars(12), precision(12);

	std::ofstream outfile;
	Nchars << 5, 20, 20, 20, 20, 24, 20, 16, 16, 16, 16, 10;
	precision << 1, 10, 10, 10 , 8, 10, 8, 8, 8, 2, 8, 3;
	
	if(append == false){
		outfile.open(file_out.c_str());	
	} else{
		outfile.open(file_out.c_str(), std::ios::app);	
	}
	if(outfile.is_open()){
		outfile << "# Configuration of mode parameters. This file was generated by write_star_mode_params_Alm (write_star_params.cpp)" << std::endl;
		outfile << "# Input mode parameters. degree / freq / H / W / a1  / eta0 / epsilon_Alm / theta0_Alm / delta_Alm /  a3  /asymetry / inclination" << std::endl;
		for(int i=0; i<mode_params.rows(); i++){
			for(int j=0;j<mode_params.cols(); j++){
				outfile << std::setw(Nchars[j]) << std::setprecision(precision[j]) << mode_params(i,j);
			}
			outfile << std::endl;
		}
		outfile.close();
	}  
	else {
		file_read_error(file_out);
	}
}

void write_star_mode_params_aj(MatrixXd mode_params, std::string file_out, bool append){

	VectorXi Nchars(16), precision(16);

	std::ofstream outfile;
	Nchars << 5, 20, 20, 20, 16, 16, 16 , 16, 16, 16, 20, 16, 16, 16, 16, 10;
	precision << 1, 10, 10, 10, 10, 10, 10, 10 , 10, 10, 8, 8, 8, 2, 8, 3;
	
	if(append == false){
		outfile.open(file_out.c_str());	
	} else{
		outfile.open(file_out.c_str(), std::ios::app);	
	}
	if(outfile.is_open()){
		outfile << "# Configuration of mode parameters. This file was generated by write_star_mode_params_aj (write_star_params.cpp)" << std::endl;
		outfile << "# Input mode parameters. degree / freq / H / W / a1  / a2  /  a3  /  a4  /  a5  /  a6  / asymetry / inclination" << std::endl;
		for(int i=0; i<mode_params.rows(); i++){
			for(int j=0;j<mode_params.cols(); j++){
				outfile << std::setw(Nchars[j]) << std::setprecision(precision[j]) << mode_params(i,j);
			}
			outfile << std::endl;
		}
		outfile.close();
	}  
	else {
		file_read_error(file_out);
	}
}

void write_star_noise_params(MatrixXd noise_params, std::string file_out, bool append){

	VectorXi Nchars(3), precision(3);

	std::ofstream outfile;

	Nchars << 16, 16, 16;
	precision << 6, 6, 6;

	if (append == false){
		outfile.open(file_out.c_str());
	} else{
		outfile.open(file_out.c_str(), std::ios::app);
	}
	if(outfile.is_open()){

		outfile << "# Configuration of mode parameters. This file was generated by write_star_mode_params (write_star_params.cpp)" << std::endl;
		outfile << "# Input mode parameters. H0 , tau_0 , p0 / H1, tau_1, p1 / N0. Set at -1 if not used. -2 means that the parameter is not even written on the file (because irrelevant)." << std::endl;
		
		for(int i=0; i<noise_params.rows(); i++){
			for(int j=0;j<noise_params.cols(); j++){
				outfile << std::setw(Nchars[j]) << std::setprecision(precision[j]) << noise_params(i,j);
			}
			outfile << std::endl;
		}
		outfile.close();
	}  
	else {
		file_read_error(file_out);
	}

}

void write_range_modes(Cfg_synthetic_star cfg_star, Params_synthetic_star params, std::string output_file){

	const int Nchars=20;
	const int precision=6;

	std::ofstream outfile;
	outfile.open(output_file.c_str());
	if (outfile.is_open()){
		outfile << "# numax and min and max frequencies for the relevant modes. The third parameter is nmax_star, the position of the curvature for the 2nd order equation of Freqs. This file was generated by io_star_params.cpp" << std::endl;
		outfile << std::setw(Nchars) << std::setprecision(precision) << cfg_star.numax_star;
		outfile << std::setw(Nchars) << std::setprecision(precision) << cfg_star.fmin;
		outfile << std::setw(Nchars) << std::setprecision(precision) << cfg_star.fmax;
		outfile << std::setw(Nchars) << std::setprecision(precision) << cfg_star.nmax_star;
	}
	outfile.close();
}


// Procedure that write a MCMC file, suited for my CPP MCMC program
// This MCMC file is on the Main-Sequence format (not suitable for my MCMC code for fitting evolved stars)
// Here file_cfg_common_params is a file that contain a pre-formated text with the common parameters to be used 
VectorXd write_star_model(const MatrixXd mode_params, const MatrixXd noise_params, const std::string file_out,
													const std::string identifier, const std::string modelname, const std::string common_template_dir){

	// Calculates Dnu and C_l from the list of l=0 frequencies
	const std::string cfg_template=common_template_dir + "use_template.cfg";
	const std::string type_mode="p";
	const int err =1;
	bool passed=0;
	int cpt;
	long double n0, Dnu, C_l, Nmodes, lmax;
	std::string chain="";
	std::string template_file;
	std::vector<std::string> cfg;
	std::vector<double> noise_s2;
	VectorXi po, l0=where_dbl(mode_params.col(0), 0, 0.001);
	VectorXd nu0(l0.size());
	VectorXd xfit, yfit, mode_range(2),f;
	VectorXd priors(6);
	priors << 0, 0, 0, 0, 0, 0;

	VectorXi Nchars(6), precision(6);
	Nchars    << 5, 20, 20, 20, 20, 20;
	precision << 0, 10, 10, 10, 10, 10;

	std::ofstream outfile;

	cfg=read_allfile_vect(cfg_template); // Vector with element 0 having a boolean and the next line(s) the files to be used as template

	for(int i=0;i<l0.size();i++){nu0[i]=mode_params(l0[i],1);}
	
	xfit=linspace(0, nu0.size()-1, nu0.size());
	yfit=linfit(xfit, nu0);
	Dnu=yfit[0];
	n0=floor(yfit[1]/Dnu);
	C_l=yfit[1]-n0*Dnu; //this should be epsilon*Dnu

	mode_range << mode_params.col(1).minCoeff() - 2*Dnu, mode_params.col(1).maxCoeff() +2*Dnu;
	lmax=mode_params.col(0).maxCoeff();
	
	outfile.open(file_out.c_str());
	if(outfile.is_open()){
		outfile << "#KIC="  << identifier << std::endl;
		outfile << "!n -9999.   # numax (optional and used only in some models. See docs). Set to -9999 if not used or remove the whole line" << std::endl;
		outfile <<  "! " << Dnu << std::endl;
		outfile << "!! " << C_l << std::endl;
		outfile << "* " << mode_range[0] << " " << mode_range[1] << std::endl;
		outfile << "# type / l / value / relax_f / relax_H / relax_W" << std::endl;
		for(int el=0; el<=lmax; el++){
			po=where_dbl(mode_params.col(0), el, 0.001); //where(mode_params.col(0), el);
			for(int i=0; i<po.size(); i++){
				outfile << type_mode << "  " << el << "  " << mode_params(po[i],1) << "  1      1     1" << std::endl;
			}
		}
		outfile << "# hyper priors" << std::endl;
		outfile << "#  Extra parameters (obselete)" << std::endl;
		outfile << priors << std::endl;
		// in the order : l / nu / window_min / Window_max / Gamma / H
		outfile << "# Eigen solution input parameters: l / nu / window_min / Window_max / Gamma / H" << std::endl;
		for(int i=0; i<mode_params.rows(); i++){
				outfile << std::setw(Nchars[0]) << std::setprecision(precision[0]) << mode_params(i,0); // l
				outfile << std::setw(Nchars[1]) << std::setprecision(precision[1]) << mode_params(i,1); // nu
				outfile << std::setw(Nchars[2]) << std::setprecision(precision[2]) << mode_params(i,1) - mode_params(i,3) - mode_params(i,4); // win_min= nu - width - splitting
				outfile << std::setw(Nchars[3]) << std::setprecision(precision[3]) << mode_params(i,1) + mode_params(i,3) + mode_params(i,4); // win_max= nu + width + splitting
				outfile << std::setw(Nchars[4]) << std::setprecision(precision[4]) << mode_params(i,3); // width
				outfile << std::setw(Nchars[5]) << std::setprecision(precision[5]) << mode_params(i,2); // height
				outfile << std::endl;
		}
		outfile << "# Noise parameters: A0/B0/p0, A1/B1/p1, A2/B2/p2, N0" << std::endl;
		cpt=0;
		for (int i=0; i<noise_params.rows(); i++){
			for (int j=0; j<noise_params.cols(); j++){
				if (noise_params(i,j) != -2 && noise_params(i,j) !=-1){
					outfile << std::setw(10) << std::setprecision(4) << noise_params(i,j);
					noise_s2.push_back(noise_params(i,j));
				}
				if (noise_params(i,j) ==-1){
					if(cpt<2){
						chain = chain + "    0       ";
						noise_s2.push_back(0);
						cpt=cpt+1;
					} else{
						chain = chain + "1";
						noise_s2.push_back(1);
						outfile << chain;
						chain="";
						cpt=0;
					}
				}
			}
			outfile << std::endl;
		}
		outfile << "# Noise Info from output_s2 (use as priors): params / err_m / err_p" << std::endl;
		for(int i=0; i<noise_s2.size(); i++){
			if(noise_s2[i] != -1){
				outfile << noise_s2[i] << std::setw(10) << std::setprecision(4) << noise_s2[i] - noise_s2[i]*0.1 
			      		               << std::setw(10) << std::setprecision(4) << noise_s2[i] + noise_s2[i]*0.1 << std::endl;
			} else {
				outfile << noise_s2[i] << "  -1.0000 -1.0000" << std::endl;
			}
		}
		passed=0;
		if (cfg[0] != "True" && cfg[0] != "False"){
			std::cout << "Error in the configuration of the common template configuration file" << std::endl;
			std::cout << "You need to review the first line of the file: " << cfg_template << std::endl;
			std::cout << "The line must contain either 'True' or 'False'" << std::endl;
			exit(EXIT_FAILURE);
		}
		if (cfg[0] == "True"){
			common_use_file_template(outfile, common_template_dir + cfg[1]);
			passed=1;
		} else{
			if (modelname == "model_MS_Global_a1etaAlma3_HarveyLike"){
				  common_model_MS_Global_a1etaAlma3_HarveyLike(outfile, mode_params);
					passed=1;
			}
			if (modelname == "model_MS_Global_aj_HarveyLike"){
					common_model_MS_Global_aj_HarveyLike(outfile, mode_params);
					passed=1;
			}
			if (modelname == "model_MS_Global_a1a2a3_HarveyLike"){
					common_model_MS_Global_a1a2a3_HarveyLike(outfile, mode_params);
					passed=0;
					std::cout << "This modelname was not tested for the creation of .model files" << std::endl;
					std::cout << "You need to perform checks to verify that the .model file is created properly before pursuing" << std::endl;
					std::cout << "The program will exit now after having created a single .model file that you could check" << std::endl;
					std::cout << "Once you are satisfied, you can erase the section showing this message and set passed=1" << std::endl;
			}
		}
	outfile.close();

	} else{
		std::cout << "Error: Could not write files on : " << file_out << std::endl;
		std::cout << "       Check that the patch exists" << std::endl;
		std::cout << "       The program will exit now"   << std::endl;
		exit(EXIT_FAILURE);
	}
	if (passed == 0){
		std::cout << " Model name invalid or model not yet tested" << std::endl;
		std::cout << " The program will exit now" << std::endl;
		exit(EXIT_SUCCESS);
	}
	//exit(EXIT_SUCCESS);
	return mode_range;
}

// To convert the .in files into .model files that can be handled with the CPP TAMCMC
void convert_in_to_model(const std::string file_out, const std::string identifier){

	std::cout << "NEED TO BE WRITTEN" << std::endl;
  
}

void write_spectrum(const VectorXd x, const VectorXd y, const VectorXd z, const std::string file_out, const bool write_inmodel){
	write_spectrum(x, y, z, file_out, write_inmodel, -1, -1);
}

void write_spectrum(const VectorXd x, const VectorXd y, const VectorXd z, const std::string file_out, const bool write_inmodel, const double fmin, const double fmax){

	int imin, imax;

	VectorXi Nchars(3), precision(3), valid_range;

	std::ofstream outfile;

	Nchars << 20, 20, 20;
	precision << 10, 10, 7;

	if(fmin <0 || fmax <0 || fmax < fmin){ // If there is an invalid range then write all data
		imin=0;
		imax=x.size();
	} else{
		valid_range=where_in_range(x, fmin, fmax, 0);
		imin=valid_range.minCoeff();
		imax=valid_range.maxCoeff();
	}

	outfile.open(file_out.c_str());
	if(outfile.is_open()){

        if(write_inmodel == 1){
            outfile << "#       freq (microHz)    spectrum (ppm2/microHz)   model spectrum (ppm2/microHz)" << std::endl;
        } else{
            outfile << "#       freq (microHz)    spectrum (ppm2/microHz)" << std::endl;
        }
     
		for(int i=imin; i<imax; i++){
			outfile << std::setw(Nchars[0]) << std::setprecision(precision[0]) << x[i];
			outfile << std::setw(Nchars[1]) << std::setprecision(precision[1]) << y[i];
			if(write_inmodel == 1){
                outfile << std::setw(Nchars[2]) << std::setprecision(precision[2]) << z[i];
            }
			outfile << std::endl;
		}
		outfile.close();
	}  
	else {
		std::cout << " Unable to open file " << file_out << std::endl;	
		std::cout << " Check that the full path exists" << std::endl;
		std::cout << " The program will exit now" << std::endl;
		exit(EXIT_FAILURE);
	}

}

void write_spectrum(const VectorXd x, const VectorXd y, const VectorXd z, const double scoef1, double scoef2, const std::string file_out){
/* 
 * Same as write_spectrum, but we add two columns with values for the smooth of the vector y using a boxcar
 * With a smooth coeficient scoef1 (column 2) or scoef2 (column 3).
 *
*/
	VectorXi Nchars(3), precision(3);
	VectorXd ys1, ys2;

	std::ofstream outfile;

    //std::cout << " - write_spectrum_v2..." << std::endl;

	Nchars << 20, 20, 20;
	precision << 10, 10, 7;

    //std::cout << " - scoef1:" << scoef1 << std::endl;
	ys1=smooth(y, scoef1);
    //if(scoef1 == scoef2){ scoef2=1.5*scoef1;}
    //std::cout << " - scoef2:" << scoef2 << std::endl;
	ys2=smooth(y, scoef2);

    //std::cout << " - Writing spectrum info..." << std::endl;
	outfile.open(file_out.c_str());
	if(outfile.is_open()){

		outfile << "#       freq (microHz)    spectrum (ppm2/microHz)   smooth spectrum (scoef1)    smooth spectrum (scoef2)    model spectrum (ppm2/microHz)" << std::endl;
		
		for(int i=0; i<x.size(); i++){
			outfile << std::setw(Nchars[0]) << std::setprecision(precision[0]) << x[i];
			outfile << std::setw(Nchars[1]) << std::setprecision(precision[1]) << y[i];
			outfile << std::setw(Nchars[1]) << std::setprecision(precision[1]) << ys1[i];
			outfile << std::setw(Nchars[1]) << std::setprecision(precision[1]) << ys2[i];
			outfile << std::setw(Nchars[2]) << std::setprecision(precision[2]) << z[i];
			outfile << std::endl;
		}
		outfile.close();
        //std::cout << " - Done." << std::endl;

    }
	else {
		std::cout << " Unable to open file " << file_out << std::endl;	
		std::cout << " Check that the full path exists" << std::endl;
		std::cout << " The program will exit now" << std::endl;
		exit(EXIT_FAILURE);
	}

}

VectorXd smooth(const VectorXd in, const double scoef){
/* 
 * Return a boxcar smooth of a vector. The smooth coeficient
 * is in natural unit of the vector (ie, microHz not in bins)
*/

  VectorXd out(in.size());
  const double dx=std::abs(in[1]-in[0]);
  double Nbins_d=scoef/dx;
  int Nbins=floor(Nbins_d);
  //Nbins_d=scoef/dx;
  //Nbins=int(Nbins_d);

  if(Nbins >= in.size()/3){
      Nbins=in.size()/6;
  }
  if(Nbins > 1){
  	if(Nbins%2 != 0){Nbins=Nbins +1;} // ensure that the Nbins/2 is an integer
      //std::cout << "[1] Nbins_d=" << Nbins_d << "    Nbins=" << Nbins << "    dx=" << dx << "     in.size()=" << out.size() << std::endl;

 	 //std::cout << "Nbins_d=" << Nbins_d << std::endl;
  	 //std::cout << "Nbins=" << Nbins << std::endl;
 	 for (int i=Nbins; i<in.size()-Nbins; i++){
		out[i]=in.segment(i- Nbins/2, Nbins).sum()/Nbins; // Centered average
	  }
	  //std::cout << " - Passed loop 1" << std::endl;
	  for (int i=0; i<Nbins; i++){
          //std::cout << "i= " << i << "   i+Nbins/2 =" << i+Nbins/2;
		  out[i]=in.segment(0, i+Nbins/2).sum()/(i+Nbins/2); // Right side average
          //std::cout << "    passed " << std::endl;
	  }
	  //std::cout << " - Passed loop 2" << std::endl;
	  for (int i=in.size()-1-Nbins; i<in.size(); i++){
		out[i]=in.segment(i-Nbins/2, in.size()-1-i).sum()/(in.size()-1-i); // Left side average
		//std::cout << "out[" << i << "]=" << out[i];
	  }
	  //std::cout << " - Passed loop 3" << std::endl;
  } else {
	out=in;
  }

return out;
}

std::string read_allfile(const std::string file){
	std::ifstream file_in;
    std::string line0;
	std::string out="";
	file_in.open(file.c_str());
    if (file_in.is_open()) {
    	 while(!file_in.eof()){
    	 	std::getline(file_in, line0);
    	 	if(line0 != ""){
    	 		if (out ==""){ // To avoid to jump line at the begining
    	 			out = line0;
    	 		} else{
    	 			out = out + "\n" + line0;
    	 		}
    	 	}
    	 }
    } else{
    	file_read_error(file);
    }
    return out;
}

std::vector<std::string> read_allfile_vect(const std::string file){
	std::ifstream file_in;
    std::string line0;
	std::vector<std::string> out;
	file_in.open(file.c_str());
    if (file_in.is_open()) {
    	 while(!file_in.eof()){
    	 	std::getline(file_in, line0);
    	 	out.push_back(line0);
    	 }
    } else{
    	file_read_error(file);
    }
    return out;
}

 Cfg_synthetic_star read_theoretical_freqs(const std::string file){
	std::ifstream file_in;
	//std::vector<std::string> read_allfile_vect(file); // Each line in a vector
	Cfg_synthetic_star cfg_star;
	//VectorXi Nf_el(4); // How many modes of each degree
	std::vector<int> pos_l, l_vec; // temporary vector
	std::vector<double> nu_vec; // temporary vector
	std::vector<std::string> tmp_vec_str;
	std::string line0, subline0;
	//
	int cpt, cptmax=10; //maximum number of header lines
    file_in.open(file.c_str());
    if (file_in.is_open()) {
		std::cout << "Mixed modes configuration file opened... processing lines" << std::endl;

		// [1] Ignore the header
		cpt=0;
		std::getline(file_in, line0);
		line0=strtrim(line0); // remove any white space at the begining/end of the string
		subline0=strtrim(line0.substr(0, 1)); // pick the first character
		subline0=subline0.c_str();
		while(subline0 == "#" && !file_in.eof() && cpt < cptmax){
			std::getline(file_in, line0);
			line0=strtrim(line0); // remove any white space at the begining/end of the string
			subline0=strtrim(line0.substr(0, 1)); // pick the first character
			subline0=subline0.c_str();
			cpt=cpt+1;
		}
		//std::cout << "After comments" << std::endl;
		if(cpt > cptmax){
			std::cout << "Only comments were found on the file!" << std::endl;
			std::cout << "Maximum authorized comment lines: " << cptmax << std::endl;
			std::cout << "Debug required" <<std::endl;
			std::cout << "The program will exit now" << std::endl;
			exit(EXIT_FAILURE);
		}
		// [2] Get relevant data
		//     Global parameters Dnu, DP, q, alpha_g
		cfg_star.use_nu_nl=str_to_bool(rem_comments(line0, "#")); // Get the value telling us whether we use frequencies from the table or not
		std::cout << "[1] cfg_star.use_nu_nl=" << cfg_star.use_nu_nl << std::endl;
		std::getline(file_in, line0); // SKIP COMMENT
		std::getline(file_in, line0);
		tmp_vec_str=strsplit(rem_comments(line0, "#"), "=");
		cfg_star.Dnu_star=str_to_dbl(tmp_vec_str[1]);
		//std::cout << str_to_dbl(tmp_vec_str[0]) << "   " << str_to_dbl(tmp_vec_str[1]) << std::endl;
		std::cout << "[2] cfg_star.Dnu_star=" << cfg_star.Dnu_star << std::endl;
		std::getline(file_in, line0);
		tmp_vec_str=strsplit(rem_comments(line0, "#"), "=");
		cfg_star.DPl_star=str_to_dbl(tmp_vec_str[1]);
		std::cout << "[3] cfg_star.DPl_star=" << cfg_star.DPl_star << std::endl;
		std::getline(file_in, line0);
		tmp_vec_str=strsplit(rem_comments(line0, "#"), "=");
		cfg_star.q_star=str_to_dbl(tmp_vec_str[1]);
		std::cout << "[4] cfg_star.q_star=" << cfg_star.q_star << std::endl;
		std::getline(file_in, line0);
		tmp_vec_str=strsplit(rem_comments(line0, "#"), "=");
		cfg_star.alpha_g_star=str_to_dbl(tmp_vec_str[1]);
		std::cout << "[5] cfg_star.alpha_g_star=" << cfg_star.alpha_g_star << std::endl;
		//     The frequencies
		std::getline(file_in, line0); // SKIP A COMMENT LINE 
		//std::cout << "[5] " << line0 << std::endl;
		cpt=0;
		cptmax=1000;
		std::cout << "[6] " << "Vectors ..." << std::endl;
		while(!file_in.eof() && cpt < cptmax){
			std::getline(file_in, line0); // Read the lines
			if (line0 != ""){
				//std::cout << "line0 =" << line0 << std::endl;
				tmp_vec_str=strsplit(rem_comments(line0, "#"), " "); // we expect l and nu_nl
				//std::cout << "  [" << cpt << "/" << cptmax << "]   tmp_vec_str[0] =" << tmp_vec_str[0] << std::endl;
				//std::cout << "  [" << cpt << "/" << cptmax << "]   tmp_vec_str[1] =" << tmp_vec_str[1] << std::endl;
				l_vec.push_back(str_to_int(tmp_vec_str[0]));
				nu_vec.push_back(str_to_dbl(tmp_vec_str[1]));
			}
			cpt=cpt+1;
		}
		file_in.close();
	} else {
		std::cout << "Could not open the configuration file!" << std::endl;
		std::cout << "Configuration file: " << file << std::endl;
		exit(EXIT_FAILURE);
	}
/*
	for (int i=0; i<l_vec.size(); i++){
		std::cout << l_vec[i] << "   " << nu_vec[i] << std::endl;
	}
	exit(EXIT_SUCCESS);
*/
	cfg_star.Nf_el.resize(4);
	// [3] Organize the frequencies in cfg_star.nu_nl
	for (int el=0; el<4; el++){
		pos_l=where_int(l_vec, el);
		if (pos_l[0] != -1){
			cfg_star.Nf_el[el]=pos_l.size();
		} else{
			cfg_star.Nf_el[el]=0;
		}
	}
	std::cout << "cfg_star.Nf_el =" << cfg_star.Nf_el.transpose() << std::endl;
	cfg_star.nu_nl.resize(4, cfg_star.Nf_el.maxCoeff()); // The size of the matrix is the larger number of modes
	cfg_star.nu_nl.setZero();
	for (int el=0; el<4; el++){
		pos_l=where_int(l_vec, el);
		for (int n=0; n<cfg_star.Nf_el[el];n++){
			//std::cout << "[" << n << "]  " << nu_vec[pos_l[n]] << std::endl;
			cfg_star.nu_nl(el, n)=nu_vec[pos_l[n]];
		}
	}
	//std::cout << cfg_star.nu_nl << std::endl;
	//std::cout << "All good" << std::endl;
	//exit(EXIT_SUCCESS);
	return cfg_star;
}


Star_params read_star_params(const std::string file_in_name){

    const int data_Maxsize=1000; 

	bool verbose_data=1, passed=0;
	int Nrows, cpt;
	long double tmp_val;
    std::ifstream file_in;
    std::vector<std::string> data_str;
    std::string line0, subline0;

	Star_params params;

	file_in.open(file_in_name.c_str());
    if (file_in.is_open()) {
		if (verbose_data == 1) {std::cout << "Reference file " << file_in_name << " opened... processing..." << std::endl;}

		// [1] Get the ID
		cpt=0;
		std::getline(file_in, line0);
		line0=strtrim(line0); // remove any white space at the begining/end of the string
		subline0=strtrim(line0.substr(0, 1)); // pick the first character
		subline0=subline0.c_str();
		passed=0;
		while(subline0 == "#"){	
				std::getline(file_in, line0);
				line0=strtrim(line0); // remove any white space at the begining/end of the string
				subline0=strtrim(line0.substr(0, 1)); // pick the first character
				subline0=subline0.c_str();		
				cpt=cpt+1;
				passed=1;
		}
		if (passed ==0){
			std::cout << "   [1] First comment line(s) not found. Beware that this is really a .in file! Attempting to pursuing operations..." << std::endl;
		}
		data_str=strsplit(line0, " ");
		if (data_str.size() == 1){
			params.identifier=strtrim(line0); // After header comments, we must have the ID
			if(verbose_data == 1){ std::cout << "Identifier : " << params.identifier << std::endl;}
		} else{
			std::cout << "Incorrect format for the Identifier! " << std::endl;
			std::cout << "The identifier should appear in a single line and must not contain spaces" << std::endl;
			std::cout << "The program will exit now" << std::endl;
			exit(EXIT_FAILURE);
		}
		// [2] Get the observation duration and the cadence (if any)
		std::getline(file_in, line0);
		line0=strtrim(line0); // remove any white space at the begining/end of the string
		subline0=strtrim(line0.substr(0, 1)); // pick the first character
		subline0=subline0.c_str();
		passed=0;
		while(subline0 == "#"){		
				std::getline(file_in, line0);
				line0=strtrim(line0); // remove any white space at the begining/end of the string
				subline0=strtrim(line0.substr(0, 1)); // pick the first character
				subline0=subline0.c_str();		
				cpt=cpt+1;
				passed=1;
		}
		if (passed == 0){
			std::cout << "   [2] Second group of comments line(s) not found. Beware that this is really a .in file! Attempting to pursuing operations..." << std::endl;
		}
		data_str=strsplit(line0, " ");
		if (data_str.size() == 2){ // After the second group of comments, we might have the the observation duration and the cadence
			params.Tobs=str_to_dbl(strtrim(data_str[0])); 
			params.cadence=str_to_dbl(strtrim(data_str[1]));
			if (verbose_data == 1){
				std::cout << "    [2] Found Tobs and Cadence information..." << std::endl;
				std::cout << "  Tobs = " << params.Tobs << std::endl;
				std::cout << "  Cadence = " << params.cadence << std::endl;
			}
		} else{ // Otherwise, it must be the mode parameters. We warn the user about the anomalous file, but attempt to continue to read the rest
			std::cout << "Warning: Could not find the line corresponding to the observation and cadence!" << std::endl;
			std::cout << "         It should be a line with two entries only, separated by spaces." << std::endl;
			std::cout << "         The file may not be a proper in file... please check..." << std::endl;
			std::cout << "         Setting Tobs = -1 and Cadence = -1" << std::endl;
			std::cout << "         Attempting to pursue, assuming that what follows is the matrix of mode parameters..." << std::endl;
		}

		// [3] Read the mode parameters...
		if (verbose_data == 1) {std::cout <<  "   [3] Now processing the mode parameters..." << std::endl;}
		
		std::getline(file_in, line0);
		line0=strtrim(line0); // remove any white space at the begining/end of the string
		subline0=strtrim(line0.substr(0, 1)); // pick the first character
		subline0=subline0.c_str();
		passed=0;
		while(subline0 == "#"){		
				std::getline(file_in, line0);
				line0=strtrim(line0); // remove any white space at the begining/end of the string
				subline0=strtrim(line0.substr(0, 1)); // pick the first character
				subline0=subline0.c_str();		
				cpt=cpt+1;
				passed=1;
		}
		Nrows=0;
		subline0=" ";
	    while(!file_in.eof() && subline0 != "#"){
			data_str=strsplit(strtrim(line0), " \t"); 
			if (Nrows == 0) {
				params.mode_params.resize(data_Maxsize, data_str.size());
				params.mode_params.setConstant(-1);
			}
			for(int i=0; i<data_str.size();i++){
				if ( ! (std::istringstream(data_str[i]) >> tmp_val) ){tmp_val = nan("");} // If the number can be converted, then tmp_val=value. Otherwise tmp_val = NaN
				params.mode_params(Nrows, i)=tmp_val;		
			}
			if (verbose_data == 1) {std::cout << params.mode_params.row(Nrows) << std::endl;} // Show all entries only if requested
			std::getline(file_in, line0);
			line0=strtrim(line0); // remove any white space at the begining/end of the string
			subline0=strtrim(line0.substr(0, 1)); // pick the first character
			subline0=subline0.c_str();
			Nrows=Nrows+1;
	    }		
	    params.mode_params.conservativeResize(Nrows, params.mode_params.cols());
		if (verbose_data == 1) {
			std::cout << "         - Number of modes found: " << Nrows << std::endl;
			std::cout << "         - Number of mode parameters found: " << params.mode_params.cols() << std::endl;
		}
	    if(subline0 == "#"){ // After all mode parameters, we must have a comment line to anounce the section with noise parameters
			std::getline(file_in, line0);
			Nrows=0;
			subline0=" ";
			if (verbose_data == 1) {std::cout <<  "   [4] Now processing the noise parameters..." << std::endl;}
	    	while(!file_in.eof()){
				data_str=strsplit(strtrim(line0), " \t"); 
				if (Nrows == 0) {
					params.noise_params.resize(data_Maxsize, data_str.size());
					params.noise_params.setConstant(-2);
				}
				for(int i=0; i<data_str.size();i++){
					if ( ! (std::istringstream(data_str[i]) >> tmp_val) ){tmp_val = nan("");} // If the number can be converted, then tmp_val=value. Otherwise tmp_val = NaN
					params.noise_params(Nrows, i)=tmp_val;		
				}
				if (verbose_data == 1) {std::cout << params.noise_params.row(Nrows) << std::endl;} // Show all entries only if requested
				std::getline(file_in, line0);
				Nrows=Nrows+1;
		    }
			data_str=strsplit(strtrim(line0), " \t"); 
			for(int i=0; i<data_str.size();i++){
				if ( ! (std::istringstream(data_str[i]) >> tmp_val) ){tmp_val = nan("");} // If the number can be converted, then tmp_val=value. Otherwise tmp_val = NaN
				params.noise_params(Nrows, i)=tmp_val;		
			}
			Nrows=Nrows+1;
			if (verbose_data == 1) {std::cout << params.noise_params.row(Nrows) << std::endl;} // Show all entries only if requested
		    params.noise_params.conservativeResize(Nrows, params.noise_params.cols());
		if (verbose_data == 1) {
			std::cout << "         - Number of lines for noise parameters found: " << Nrows+1 << std::endl;
			std::cout << "         - Number of columns for noise parameters found: " << params.noise_params.cols() << std::endl;
		}
	    } else{ // If this is not the case, then there is something wrong and we have to stop the program
	    	std::cout << "Error:  Could not find the section with noise parameters" << std::endl;
	    	std::cout << "        The code looks for a comment line following the section for mode parameters, but could not find it" << std::endl;
	    	std::cout << "        Cannot pursue. The program will exit now" << std::endl;
	    	exit(EXIT_FAILURE);
	    }

	file_in.close();
	
    } else {
 		if (verbose_data == 1) {std::cout << "Reference file " << file_in_name << std::endl;}
		file_read_error(file_in_name);
    }

	return params;
}


Data_Nd read_data_ascii_Ncols(const std::string file_in_name, const std::string delimiter, const bool verbose_data){
/*
 * This function read an input file (file_in_name) which may or may not contain a header, labels, units indicator.
 * The number of column can be as small as 1
*/

    int cpt, Nrows;
    std::string line, line0, subline0; //token
    std::vector<std::string> header, labels, units, data_str;
    long double tmp_val;
    MatrixXd data;
    Data_Nd all_data_out; // The structure that encapsulate all the data, the header, the labels and units
    const int data_Maxsize=1000000; 
    std::ifstream file_in;
    if (verbose_data == 1) {
 	   std::cout << "  Assumptions for the data file: " << std::endl;
 	   std::cout << "       - header lines appear on the top of the file and are indicated by a # for first character. The header is however optional (then no # are found)" << std::endl;
 	   std::cout << "       - labels appear in one single line that is just after the  header and is indicated by a ! for first character. Labels are optional (then no ! are found)" << std::endl;
 	   std::cout << "       - units appear in one single line that is just after the  labels or the header (if the labels are missing) and is indicated by a * for first character. Units are optional (then no * are found)" << std::endl;
 	   std::cout << "       - Maximum number of lines for the data: " << data_Maxsize << std::endl;
	}
    file_in.open(file_in_name.c_str());
    if (file_in.is_open()) {
	if (verbose_data == 1) {std::cout << "Data File opened... processing lines" << std::endl;}

		// [1] Get the header
		cpt=0;
		std::getline(file_in, line0);
		line0=strtrim(line0); // remove any white space at the begining/end of the string
		subline0=strtrim(line0.substr(0, 1)); // pick the first character
		subline0=subline0.c_str();
		if (subline0 == "#"){
			while(subline0 == "#"){		
				header.push_back(strtrim(line0.substr(1, std::string::npos))); // add all characters except the first one (and any space at the begining)

				std::getline(file_in, line0);
				line0=strtrim(line0); // remove any white space at the begining/end of the string
				subline0=strtrim(line0.substr(0, 1)); // pick the first character
				subline0=subline0.c_str();
				
				cpt=cpt+1;
			}
			if (verbose_data == 1) {std::cout << "   [1] " << cpt << " header lines found..." << std::endl;}
		} else{
			header.push_back("");
			if (verbose_data == 1) {std::cout << "   [1] Header not found. Header vector set to a blank vector<string> of size 1. Pursuing operations..." << std::endl;}
		}

		// [2] Read the labels... these are expected just after the header... If not found, then labels is left blank of size 1
		// No need to read line... already read by the previous loop
		line0=strtrim(line0); // remove any white space at the begining/end of the string
		subline0=strtrim(line0.substr(0, 1)); // pick the first character
		subline0=subline0.c_str();
		if(subline0 == "!"){
			
			labels=strsplit(strtrim(line0.substr(1,std::string::npos)), " \t"); // remove either when you found a white space or a tabulation
			if (verbose_data == 1) {std::cout << "   [2] " << labels.size() << " labels found..." << std::endl;}

			for(int i=0; i<labels.size();i++){
				labels[i]=strtrim(labels[i]); // remove spaces at begining/end of each substring
				if (verbose_data == 1) {std::cout << "         - " << labels[i] << std::endl;}
			}

		} else {
			labels.push_back("");
			if (verbose_data == 1) {std::cout << "   [2] No labels found. Label vector set to a blank vector<string> of size 1. Pursuing operations..." << std::endl;}
		}
		
		// [3] Read the units... these are expected just after the labels... If not found, then units is left blank of size 1
		// Read a new line only if we found a label. Otherwise, it is not necessary...
		if (labels[0] != ""){std::getline(file_in, line0);}
		line0=strtrim(line0); 
		subline0=strtrim(line0.substr(0, 1)); 
		subline0=subline0.c_str();
		if(subline0 == "*"){
			units=strsplit(strtrim(line0.substr(1,std::string::npos)), " \t"); 
			if (verbose_data == 1) {std::cout << "   [3] " << units.size() << " units found..." << std::endl;}
			for(int i=0; i<units.size();i++){
				units[i]=strtrim(units[i]);
				if (verbose_data == 1) {std::cout << "         - " << units[i] << std::endl;}
			}
		} else {
			units.push_back("");
			if (verbose_data == 1) {std::cout << "   [3] No units found. Units vector set to a blank vector<string> of size 1." << std::endl;}
		}

		// [4] Read the data...
		if (verbose_data == 1) {std::cout <<  "   [4] Now processing the data..." << std::endl;}
		if (labels[0] != "" || units[0] != ""){  // case where we need to read a new line before looping
			std::getline(file_in, line0);
		} 
		Nrows=0;
	   while(!file_in.eof()){
		data_str=strsplit(strtrim(line0), " \t"); 
		if (Nrows == 0) {
			data.resize(data_Maxsize, data_str.size());
			data.setConstant(-2);
		}
		for(int i=0; i<data_str.size();i++){
			if ( ! (std::istringstream(data_str[i]) >> tmp_val) ){tmp_val = nan("");} // If the number can be converted, then tmp_val=value. Otherwise tmp_val = NaN
			data(Nrows, i)=tmp_val;		
		}
		if (verbose_data == 1) {std::cout << data.row(Nrows) << std::endl;} // Show all entries only if requested
		std::getline(file_in, line0);
		Nrows=Nrows+1;
	    }
	file_in.close();
	data.conservativeResize(Nrows, data.cols());
	if (verbose_data == 1) {
		std::cout << "         - Number of lines found: " << Nrows << std::endl;
		std::cout << "         - Number of columns found: " << data.cols() << std::endl;
	}
     } else {
		file_read_error(file_in_name);
	}

     all_data_out.data=data;
     all_data_out.header=header;
     all_data_out.labels=labels;
     all_data_out.units=units;

return all_data_out;
}


std::string rem_comments(std::string str0, std::string terminator){
/*
 * Simple command that remove anything after the terminatior (terminator included)
 * The command also remove blanks at the begining/end of the input string
 * Useful to remove comments
*/
	
	size_t pos;
	std::string str_out;
	
	pos = str0.find_first_of(terminator); // detect the end of the line
	if(pos != std::string::npos){	
		str_out=str0.substr(0, pos); // remove comments
		str_out=strtrim(str_out); // remove blanks
	} else {
		str_out=strtrim(str0); // remove blanks
	}

	return str_out;
}

Config_Data read_main_cfg(std::string cfg_file){

	int cpt, cptmax;
	std::string line0, subline0, tmp_str;
	std::vector<std::string> tmp_vec_str;
	std::ifstream file_in;
	std::vector<double> tmp;
	Config_Data cfg;

	
	cptmax=10; //maximum number of header lines
    	file_in.open(cfg_file.c_str());
    	if (file_in.is_open()) {
		std::cout << "Data File opened... processing lines" << std::endl;

		// [1] Ignore the header
		cpt=0;
		std::getline(file_in, line0);
		line0=strtrim(line0); // remove any white space at the begining/end of the string
		subline0=strtrim(line0.substr(0, 1)); // pick the first character
		subline0=subline0.c_str();
		while(subline0 == "#" && !file_in.eof() && cpt < cptmax){
			std::getline(file_in, line0);
			line0=strtrim(line0); // remove any white space at the begining/end of the string
			subline0=strtrim(line0.substr(0, 1)); // pick the first character
			subline0=subline0.c_str();
			cpt=cpt+1;
		}
		if(cpt > cptmax){
			std::cout << "Only comments were found on the file!" << std::endl;
			std::cout << "Maximum authorized comment lines: " << cptmax << std::endl;
			std::cout << "Debug required" <<std::endl;
			std::cout << "The program will exit now" << std::endl;
			exit(EXIT_FAILURE);
		}
		// [2] Get relevant data
		
			tmp_vec_str=strsplit(rem_comments(line0, "#"), " "); // split the line into segments of strings
			cfg.forest_type=tmp_vec_str[0]; // Get the keyword
			tmp_vec_str.erase(tmp_vec_str.begin()); // Remove the keyword before processing the parameters of the given keyword
			if(tmp_vec_str.size() >= 1) {
				cfg.forest_params=arrstr_to_arrdbl(tmp_vec_str);
			}

			std::getline(file_in, line0);
			tmp_vec_str=strsplit(rem_comments(line0, "#"), " ");
			cfg.model_name=tmp_vec_str[0];
			if(tmp_vec_str.size() > 1){
				for(int i=1; i<tmp_vec_str.size();i++){
					cfg.extra_params = cfg.extra_params +  strtrim(tmp_vec_str[i]) + " ";
				}
			}
 
			cfg.extra_params=strtrim(cfg.extra_params);

			std::getline(file_in, line0);
			cfg.template_files=strsplit(rem_comments(line0, "#"), " ");

			std::getline(file_in, line0);
			cfg.labels=strsplit(rem_comments(line0, "#"), " ");

			std::getline(file_in, line0);
			cfg.val_min=str_to_arrdbl(rem_comments(line0, "#"), " ");

			std::getline(file_in, line0);
			cfg.val_max=str_to_arrdbl(rem_comments(line0, "#"), " ");

			std::getline(file_in, line0);
			cfg.step=str_to_arrdbl(rem_comments(line0, "#"), " ");

			std::getline(file_in, line0); // skip the labels of Tobs and Cadence

			std::getline(file_in, line0);
			tmp=str_to_arrdbl(rem_comments(line0, "#"), " ");
			cfg.Tobs=tmp[0];
			cfg.Cadence=tmp[1];	
            cfg.Nspectra=tmp[2];
            cfg.Nrealisation=tmp[3];
            
			std::getline(file_in, line0);		
			cfg.erase_old_files=str_to_bool(rem_comments(line0, "#"));

      std::getline(file_in, line0);
      cfg.doplots=str_to_bool(rem_comments(line0, "#"));

      std::getline(file_in, line0);
      cfg.write_inmodel=str_to_bool(rem_comments(line0, "#"));
 
      std::getline(file_in, line0);
      cfg.limit_data_range=str_to_bool(rem_comments(line0, "#"));
      			
      std::getline(file_in, line0);
      tmp_vec_str=strsplit(rem_comments(line0, "#"), " "); // split the line into segments of strings
      cfg.do_modelfiles=str_to_bool(tmp_vec_str[0]);
      if (tmp_vec_str.size() > 1){
		cfg.modefile_modelname=strtrim(tmp_vec_str[1]);
      } else{
      	cfg.modefile_modelname="";
      }
	  file_in.close();
	} else {
		std::cout << "Could not open the configuration file!" << std::endl;
		std::cout << "Configuration file: " << cfg_file << std::endl;
		exit(EXIT_FAILURE);

	}
	if(cfg.step.size() != cfg.val_min.size() && cfg.step.size() != cfg.val_max.size()){
		std::cout << "The configuration file contains input vectors (val_min, val_max, step) of different size" << std::endl;
		std::cout << "The input vectors must gave the same size!" << std::endl;
		std::cout << "Please check your configuration file" << std::endl;
		std::cout << "The program will stop now" << std::endl;
		std::cout << "cfg.step.size()=" <<  cfg.step.size() << std::endl;
		std::cout << "cfg.val_min.size()=" << cfg.val_min.size() << std::endl;
		std::cout << "cfg.val_max.size()=" << cfg.val_max.size() << std::endl;
		exit(EXIT_FAILURE);
	}
	
	// ------- Verbose setup ------
	std::cout << "   cfg.model_name = ";
	std::cout << cfg.model_name << std::endl;

	std::cout << "   cfg.forest_type = " << cfg.forest_type << std::endl;
	std::cout << "   cfg.forest_params = ";
	for(int i=0; i<cfg.forest_params.size(); i++){
		std::cout << cfg.forest_params[i] << "  ";
	}
	std::cout << std::endl;

	std::cout << "   cfg.labels  = ";
	for(int i=0; i<cfg.labels.size(); i++){
		std::cout << std::setw(4) << cfg.labels[i] << "  ";
	}
	std::cout << std::endl;
	std::cout << "   cfg.val_min = ";
	for(int i=0; i<cfg.val_min.size(); i++){
		std::cout << std::setw(4) << cfg.val_min[i] << "  ";
	}
	std::cout << std::endl;
	std::cout << "   cfg.val_max = ";
	for(int i=0; i<cfg.val_max.size(); i++){
		std::cout << std::setw(4) << cfg.val_max[i] << "  ";
	}
	std::cout << std::endl;
	std::cout << "   cfg.step    = ";
	for(int i=0; i<cfg.step.size(); i++){
		std::cout << std::setw(4) << cfg.step[i] << "  ";
	}
	std::cout << std::endl;

	std::cout << "   cfg.Tobs = " << cfg.Tobs << std::endl;
	std::cout << "   cfg.Cadence = " << cfg.Cadence << std::endl;
	std::cout << "   cfg.erase_old_files = " << cfg.erase_old_files << std::endl;
	// -------------------

	return cfg;
}

/*bool file_exists(const std::string& name) {
    return ( access( name.c_str(), F_OK ) != -1 );
}
*/

MatrixXd bumpoutputs_2_MatrixXd(Params_synthetic_star params, double inc){
	int i, cpt=0;
	int Nt=params.nu_l0.size() + params.nu_m_l1.size() + params.nu_l2.size() + params.nu_l3.size();
	MatrixXd mode_params(Nt, 11);

	for (i=0;i<params.nu_l0.size();i++){
		mode_params(cpt, 0)=0;
		mode_params(cpt, 1)=params.nu_l0[i];
		mode_params(cpt, 2)=params.height_l0[i];
		mode_params(cpt, 3)=params.width_l0[i];
		mode_params(cpt, 4)=0; // a1 is 0 for l=0
		mode_params(cpt, 5)=0; // eta is 0 in simulations
		mode_params(cpt, 6)=0; // a3 is 0 in simulations
		mode_params(cpt, 7)=0; // b is 0 in simulations
		mode_params(cpt, 8)=0; // alfa is 0 in simulations
		mode_params(cpt, 9)=0; // asym is 0 in simulations
		mode_params(cpt, 10)=inc; // inc	
		cpt=cpt+1;
	}
	for (i=0;i<params.nu_m_l1.size();i++){
		mode_params(cpt, 0)=1;
		mode_params(cpt, 1)=params.nu_m_l1[i];
		mode_params(cpt, 2)=params.height_l1[i];
		mode_params(cpt, 3)=params.width_l1[i];
		mode_params(cpt, 4)=params.a1_l1[i]; // a1 is 0 for l=0
		mode_params(cpt, 5)=0; // eta is 0 in simulations
		mode_params(cpt, 6)=0; // a3 is 0 in simulations
		mode_params(cpt, 7)=0; // b is 0 in simulations
		mode_params(cpt, 8)=0; // alfa is 0 in simulations
		mode_params(cpt, 9)=0; // asym is 0 in simulations
		mode_params(cpt, 10)=inc; // inc	
		cpt=cpt+1;
	}
	for (i=0;i<params.nu_l2.size();i++){
		mode_params(cpt, 0)=2;
		mode_params(cpt, 1)=params.nu_l2[i];
		mode_params(cpt, 2)=params.height_l2[i];
		mode_params(cpt, 3)=params.width_l2[i];
		mode_params(cpt, 4)=params.a1_l2[i]; // a1 is 0 for l=0
		mode_params(cpt, 5)=0; // eta is 0 in simulations
		mode_params(cpt, 6)=0; // a3 is 0 in simulations
		mode_params(cpt, 7)=0; // b is 0 in simulations
		mode_params(cpt, 8)=0; // alfa is 0 in simulations
		mode_params(cpt, 9)=0; // asym is 0 in simulations
		mode_params(cpt, 10)=inc; // inc	
		cpt=cpt+1;
	}
	for (i=0;i<params.nu_l3.size();i++){
		mode_params(cpt, 0)=3;
		mode_params(cpt, 1)=params.nu_l3[i];
		mode_params(cpt, 2)=params.height_l3[i];
		mode_params(cpt, 3)=params.width_l3[i];
		mode_params(cpt, 4)=params.a1_l3[i]; // a1 is 0 for l=0
		mode_params(cpt, 5)=0; // eta is 0 in simulations
		mode_params(cpt, 6)=0; // a3 is 0 in simulations
		mode_params(cpt, 7)=0; // b is 0 in simulations
		mode_params(cpt, 8)=0; // alfa is 0 in simulations
		mode_params(cpt, 9)=0; // asym is 0 in simulations
		mode_params(cpt, 10)=inc; // inc	
		cpt=cpt+1;
	}
	return mode_params;
}


void write_global_info(VectorXd spec_params, std::string file_out, std::string identifier, bool append){
	VectorXi Nchars_spec(2),  precision_spec(2);
	
	std::ofstream outfile;

    if(outfile.is_open()){
		// ---------------------
		Nchars_spec << 20, 20;
		precision_spec << 10, 10;

		outfile << "ID= " << identifier << std::endl;

		outfile << "# Spectrum parameters. Observation duration (days) / Cadence (seconds)" << std::endl;
		outfile << std::setw(Nchars_spec[0]) << std::setprecision(precision_spec[1]) << spec_params[0];
		outfile << std::setw(Nchars_spec[1]) << std::setprecision(precision_spec[1]) << spec_params[1] << std::endl;
	}
	outfile.close();
}

void file_read_error(std::string file_out){
		std::cout << " Unable to open file " << file_out << std::endl;	
		std::cout << " Check that the full path exists" << std::endl;
		std::cout << " The program will exit now" << std::endl;
		exit(EXIT_FAILURE);
}

/*
// Small test program
int main(){
	int N=100;
	MatrixXd mode_params1(2, 8);
	MatrixXd mode_params2(3, 11);
	MatrixXd noise_params(3, 3);
	VectorXd x(N),y(N),z(N), spec_params(2);
	std::string identifier;
	std::string file_out1, file_out2, file_out3, file_out4, file_out5;
	file_out1="output_test1.txt";
	std::cout << "Test of write_star_mode_params_a1a2a3...outputs in " << file_out1 <<  std::endl;
	mode_params1.setRandom();
	
	for(int i=0; i<mode_params1.rows(); i++){
		for(int j=0; j<mode_params1.cols(); j++){
			std::cout << std::setw(10) << std::setprecision(5) << mode_params1(i,j);
		}
		std::cout << std::endl;
	}
	write_star_mode_params_a1a2a3(mode_params1, file_out1);
	std::cout << "--------------" << std::endl;
	file_out2="output_test2.txt";
	std::cout << "Test of write_star_mode_params_act_asym...outputs in " << file_out2 << std::endl;
	mode_params2.setRandom();	
	for(int i=0; i<mode_params2.rows(); i++){
		for(int j=0; j<mode_params2.cols(); j++){
			std::cout << std::setw(10) << std::setprecision(5) << mode_params2(i,j);
		}
		std::cout << std::endl;
	}
	write_star_mode_params_act_asym(mode_params2, file_out2);
	std::cout << "--------------" << std::endl;
	noise_params.setRandom();
	
	file_out3="output_test3.txt";
	std::cout << "Test of write_star_noise_params... outputs in " << file_out3 << std::endl;
	for(int i=0; i<noise_params.rows(); i++){
		for(int j=0; j<noise_params.cols(); j++){
			std::cout << std::setw(10) << std::setprecision(5) << noise_params(i,j);
		}
		std::cout << std::endl;
	}
	write_star_noise_params(noise_params, file_out3);
	std::cout << "--------------" << std::endl;
	file_out4="output_test4.txt";
	std::cout << "Test of write_spectrum...outputs in " << file_out4  << std::endl;
	x.setLinSpaced(0,1000);
	y.setRandom();
	z.setConstant(5);
	
	write_spectrum(x, y, z, file_out4);
	std::cout << "--------------" << std::endl;
	file_out5="output_test5.txt";
	std::cout << "Test of write_star_params_act_asym...outputs in " << file_out5  << std::endl;
	spec_params[0]=10;
	spec_params[1]=50;
	identifier="01234567";
	write_star_params_act_asym(spec_params, mode_params2, noise_params, file_out5, identifier);
}
*/
