/*
 * models_database.cpp
 *
 * Header file that contains all kind of methods
 * used to generate models for the pulsation/noise
 * 
 *  Created on: 20 Apr 2016
 *      Author: obenomar
 */
# include <iostream>
# include <iomanip>
#include <fstream>
# include <string>
# include <Eigen/Dense>
#include "models_database.h"
#include "noise_models.h"
#include "string_handler.h"

using Eigen::VectorXd;
using Eigen::VectorXi;
using Eigen::MatrixXd;

double *r8vec_normal_01 ( int n, int *seed );

void asymptotic_mm_v1(VectorXd input_params, std::string file_out_modes, std::string file_out_noise, std::string file_cfg_mm, std::string external_path, std::string template_file){

	int seed=(unsigned)time(NULL);
	srand(seed);

	// ----- Constants ------
	const double PI = 3.141592653589793238462643;
	const double G=6.667e-8;
	const double Teff_sun=5777;
	const double Dnu_sun=135.1;
	const double numax_sun=3150;
	const double R_sun=6.96342e5;
	const double M_sun=1.98855e30;
	const double rho_sun=M_sun*1e3/(4*PI*pow(R_sun*1e5,3)/3);
	// ----------------------
	const std::string file_range="external/ARMM-solver/star_params.range";

	//std::cout << "input_params=" << input_params.transpose() << std::endl;
	//std::cout << "input_params.size()=" << input_params.size() << std::endl;
	// ------- Deploy the parameters ------
	double Teff=input_params[0];
	double Dnu=input_params[1];
	double epsilon=input_params[2];
	double delta0l_percent=input_params[3];
	double beta_p=input_params[4];
	double nmax_spread=input_params[5];
	double DP_var_percent=input_params[6];
	double alpha=input_params[7];
	double q=input_params[8];
	double hnr_l0=input_params[9];
	double l0_width_at_numax=input_params[10];
	double Vl1=input_params[11];
	double Vl2=input_params[12];
	double Vl3=input_params[13];
	double H0_spread=input_params[14];

	double lmax=3;
	double Nmax_pm=6; // Number of radial order to inject on each side of numax
	//double N0=1.; 
	//double Hmax_l0=hnr_l0*N0;
	//double Hmax_l0=-1; // We don't use this anymore because we need to know numax to define the noise N(numax) and then calculate Hmax_l0=H_l0(numax)=hnr_l0(numax)*N(numax)
	double a1;
	
	double numax_star=-1; // This will be defined by bump_DP.py, ... we have to read the output file generated by this code ...
	std::string line;
	VectorXd data_range; // Will contain [numax, fmin, fmax] as derived by the python code

	double H, tau, p, N0;
	MatrixXd noise_params(3,3);
	//VectorXd input_noise(9);

	// ------------------------------------

	// ---- Evaluation of DP ----
	// Super rought estimate derived by visual inspection of the Mosser+2015, Fig.1
	const double c=36.8222;
	const double b=2.63897;
	const double a=0.0168202;
	double DP;
	
	DP=a*pow(Dnu, 2) + b*Dnu + c;
	double *r = r8vec_normal_01 ( 1, &seed );
	DP=DP +  *r*DP*DP_var_percent/100.; // Inject a gaussian random error of DP_var_percent
	// -----------

	// ----------- PYTHON EXTERNAL FUNCTION -------------
	// a. Generate the configuration file for the python function
	int Nchars_spec = 20;
	int precision_spec = 5;
	int sizes;
	
	std::ifstream rfile;
	std::ofstream rwfile;
	
	std::cout << "                     - Attempting to write cfg on file " << file_cfg_mm << "..." << std::endl;
	rwfile.open(file_cfg_mm.c_str());
	if(rwfile.is_open()){
		// ---------------------
		//rwfile << "# First line: Teff / Dnu / epsilon / D0. Second line: DP1 / alpha / q. Third line coupling / how many l=0 freq on left&right of numax / hmax / width at numax for l=0 / max uniform spread on numax (% or <=0 if off)" << std::endl;
		rwfile << "# First line: Teff / Dnu / epsilon / delta0l_percent / beta_p / nmax_spread. Second line: DP1 / alpha / q. Third line coupling / how many l=0 freq on left&right of numax / hmax / width at numax for l=0 / max uniform spread on numax (% or <=0 if off). Fourth line: Noise parameters" << std::endl;
		rwfile << Teff;
		rwfile << std::setw(Nchars_spec) << std::setprecision(precision_spec) << Dnu;
		rwfile << std::setw(Nchars_spec) << std::setprecision(precision_spec) << epsilon << std::setw(Nchars_spec) << delta0l_percent << std::setw(Nchars_spec) << beta_p;
		rwfile << std::setw(Nchars_spec) << nmax_spread << std::endl;
		rwfile << DP << std::setw(Nchars_spec) << alpha << std::endl;
		rwfile << q << std::setw(Nchars_spec) << Nmax_pm <<  std::setw(Nchars_spec)  << hnr_l0 <<  std::setw(Nchars_spec)  << l0_width_at_numax << std::setw(Nchars_spec) << "-1 " << std::endl;
		rwfile << Vl1 << std::setw(Nchars_spec) << Vl2 << std::setw(Nchars_spec) << Vl3 << std::setw(Nchars_spec) << H0_spread << std::endl;
		rwfile << input_params[15] << std::setw(Nchars_spec) << input_params[16] << std::setw(Nchars_spec) << input_params[17] << std::setw(Nchars_spec); // The noise parameters: P_gran
		rwfile << input_params[18] << std::setw(Nchars_spec) << input_params[19] << std::setw(Nchars_spec) << input_params[20] << std::setw(Nchars_spec); // The noise parameters: tau_gran
		rwfile << input_params[21] << std::setw(Nchars_spec) << input_params[22] << std::endl; //  The noise parameters: N0
		rwfile.close();
		std::cout << "Success... starting python3 external program..." << std::endl;
	} else{
		std::cout << "Error! Could not write the configuration file the Python external routine!" << std::endl;
		std::cout << "The program will exit now" << std::endl;
		exit(EXIT_FAILURE);
	}
	
	// b. Call the external function
	//const std::string str="python3 -c \"import bump_DP; bump_DP.main_star_generator(config_file='external/ARMM-solver/star_params.global', output_file='" + file_out_modes + "', output_file_range='external/ARMM-solver/star_params.range'" + ", output_file_rot='external/ARMM-solver/star_params.rot')\" ";
	const std::string str="python3 -c \"import bump_DP; bump_DP.main_star_generator(config_file='external/ARMM-solver/star_params.global', filetemplate='" + template_file + "', output_file='" + file_out_modes + "', output_file_range='external/ARMM-solver/star_params.range'" + ", output_file_rot='external/ARMM-solver/star_params.rot')\" ";
	const char *command = str.c_str(); 
	std::cout << "Executing command line: " << std::endl;
	std::cout << "    "  << str << std::endl;
	
	if (Dnu <= 15){
		std::cout << "    Model with small Dnu ==> many mixed modes. This might be long to find the solutions..." << std::endl; 
	}
	system(command);

	// Retrieve numax from external/ARMM-solver/star_params.range
	rfile.open(file_range.c_str());
	if(rfile.is_open()){
		std::getline(rfile, line); // The first line is a comment ===> We Ignore it
		std::getline(rfile, line); // This is the relevant line
		data_range=str_to_Xdarr(strtrim(line), " ");
		numax_star=data_range[0];
	} else{
		std::cout << "Error! Could not open the star_params.range file created by the Python external routine!" << std::endl;
		std::cout << "The program will exit now" << std::endl;
		exit(EXIT_FAILURE);
	}
	rfile.close();

	tau=input_params[18] * pow(numax_star*1e-6,input_params[19]) + input_params[20]; // Granulation timescale (in seconds)
	H=input_params[15] * pow(numax_star*1e-6,input_params[16]) + input_params[17]; // Granulation Amplitude
	H=H/tau ; //This is due to the used definition for the Harvey profile (conversion from Hz to microHz)
	tau=tau/1000. ; //conversion in ksec
	p=input_params[21];// power law:  MUST BE CLOSE TO 2
	N0=input_params[22];
	noise_params(0,0)=-1;
	noise_params(0,1)=-1;
	noise_params(0,2)=-1; 
	noise_params(1,0)=H;
	noise_params(1,1)=tau;
	noise_params(1,2)=p; 
	noise_params(2, 0)=N0; // White noise
	noise_params(2, 1)=-2;
	noise_params(2, 2)=-2;

	/*
	for(int e=0; e<3; e++){
		for(int k=0; k<3; k++){
			noise_params(e, k)=input_noise(3*e + k);
		}
	}
	*/
	// A FUNCTION THAT WRITES THE Noise
	write_star_noise_params(noise_params, file_out_noise);

	//exit(EXIT_SUCCESS);
}


void asymptotic_mm_v2(VectorXd input_params, std::string file_out_modes, std::string file_out_noise, std::string file_cfg_mm, std::string external_path, std::string template_file){

	int seed=(unsigned)time(NULL);
	srand(seed);
	
	// ----- Constants ------
	const double PI = 3.141592653589793238462643;
	const double G=6.667e-8;
	const double Teff_sun=5777;
	const double Dnu_sun=135.1;
	const double numax_sun=3150;
	const double R_sun=6.96342e5;
	const double M_sun=1.98855e30;
	const double rho_sun=M_sun*1e3/(4*PI*pow(R_sun*1e5,3)/3);
	// ----------------------
	const std::string file_range="external/ARMM-solver/star_params.range";

	//std::cout << "input_params=" << input_params.transpose() << std::endl;
	//std::cout << "input_params.size()=" << input_params.size() << std::endl;
	// ------- Deploy the parameters ------
	double rot_env=input_params[0];
	double rot_ratio=input_params[1];	
	double Dnu=input_params[2];
	double epsilon=input_params[3];
	double delta0l_percent=input_params[4];
	double beta_p=input_params[5];
	double nmax_spread=input_params[6];
	double DP_var_percent=input_params[7];
	double alpha=input_params[8];
	double q=input_params[9];
	double hnr_l0=input_params[10];
	double l0_width_at_numax=input_params[11];
	double Vl1=input_params[12];
	double Vl2=input_params[13];
	double Vl3=input_params[14];
	double H0_spread=input_params[15];

	double lmax=3;
	double Nmax_pm=6; // Number of radial order to inject on each side of numax
	//double N0=1.; 
	//double Hmax_l0=hnr_l0*N0;
	//double Hmax_l0=-1; // We don't use this anymore because we need to know numax to define the noise N(numax) and then calculate Hmax_l0=H_l0(numax)=hnr_l0(numax)*N(numax)
	double a1;
	
	double numax_star=-1; // This will be defined by bump_DP.py, ... we have to read the output file generated by this code ...
	std::string line;
	VectorXd data_range; // Will contain [numax, fmin, fmax] as derived by the python code

	double H, tau, p, N0;
	MatrixXd noise_params(3,3);
	// ------------------------------------

	// ---- Evaluation of DP ----
	// Super rought estimate derived by visual inspection of the Mosser+2015, Fig.1
	const double c=36.8222;
	const double b=2.63897;
	const double a=0.0168202;
	double DP;
	
	DP=a*pow(Dnu, 2) + b*Dnu + c;
	double *r = r8vec_normal_01 ( 1, &seed );
	DP=DP +  *r*DP*DP_var_percent/100.; // Inject a gaussian random error of 2.5%
	// -----------

	// ----------- PYTHON EXTERNAL FUNCTION -------------
	// a. Generate the configuration file for the python function
	int Nchars_spec = 20;
	int precision_spec = 5;
	int sizes;
	
	std::ifstream rfile;
	std::ofstream rwfile;
	
	std::cout << "                     - Attempting to write cfg on file " << file_cfg_mm << "..." << std::endl;
	rwfile.open(file_cfg_mm.c_str());
	if(rwfile.is_open()){
		// ---------------------
		rwfile << "# First line: rot_env / rot_ratio / Dnu / epsilon / delta0l_percent / beta_p / nmax_spread. Second line: DP1 / alpha / q. Third line coupling / how many l=0 freq on left&right of numax / hmax / width at numax for l=0 / max uniform spread on numax (% or <=0 if off). Fourth line: Noise parameters" << std::endl;
		rwfile << rot_env << std::setw(Nchars_spec) << std::setprecision(precision_spec) << rot_ratio;
		rwfile << std::setw(Nchars_spec) << std::setprecision(precision_spec) << Dnu;
		rwfile << std::setw(Nchars_spec) << std::setprecision(precision_spec) << epsilon << std::setw(Nchars_spec) << delta0l_percent << std::setw(Nchars_spec) << beta_p;
		rwfile << std::setw(Nchars_spec) << nmax_spread << std::endl;
		rwfile << DP << std::setw(Nchars_spec) << alpha << std::endl;
		rwfile << q << std::setw(Nchars_spec) << Nmax_pm <<  std::setw(Nchars_spec)  << hnr_l0  <<  std::setw(Nchars_spec)  << l0_width_at_numax << std::setw(Nchars_spec) << "-1 " << std::endl;
		rwfile << Vl1 << std::setw(Nchars_spec) << Vl2 << std::setw(Nchars_spec) << Vl3 << std::setw(Nchars_spec) << H0_spread << std::endl;
		rwfile << input_params[16] << std::setw(Nchars_spec) << input_params[17] << std::setw(Nchars_spec) << input_params[18] << std::setw(Nchars_spec); // The noise parameters: P_gran
		rwfile << input_params[19] << std::setw(Nchars_spec) << input_params[20] << std::setw(Nchars_spec) << input_params[21] << std::setw(Nchars_spec); // The noise parameters: tau_gran
		rwfile << input_params[22] << std::setw(Nchars_spec) << input_params[23] << std::endl; //  The noise parameters: N0
		rwfile.close();
		std::cout << "Success... starting python3 external program..." << std::endl;
	} else{
		std::cout << "Error! Could not write the configuration file the Python external routine!" << std::endl;
		std::cout << "The program will exit now" << std::endl;
		exit(EXIT_FAILURE);
	}
	
	// b. Call the external function
	//const std::string str="python3 -c \"import bump_DP; bump_DP.main_star_generator(config_file='external/ARMM-solver/star_params.global', output_file='" + file_out_modes + "', output_file_range='external/ARMM-solver/star_params.range'" + ", output_file_rot='external/ARMM-solver/star_params.rot', version=2)\" ";
	const std::string str="python3 -c \"import bump_DP; bump_DP.main_star_generator(config_file='external/ARMM-solver/star_params.global', filetemplate='" + template_file + "', output_file='" + file_out_modes + "', output_file_range='external/ARMM-solver/star_params.range'" + ", output_file_rot='external/ARMM-solver/star_params.rot', version=2)\" ";
	const char *command = str.c_str(); 
	std::cout << "Executing command line: " << std::endl;
	std::cout << "    "  << str << std::endl;
	
	if (Dnu <= 15){
		std::cout << "    Model with small Dnu ==> many mixed modes. This might be long to find the solutions..." << std::endl; 
	}
	system(command);

	// Retrieve numax from external/ARMM-solver/star_params.range
	rfile.open(file_range.c_str());
	if(rfile.is_open()){
		std::getline(rfile, line); // The first line is a comment ===> We Ignore it
		std::getline(rfile, line); // This is the relevant line
		data_range=str_to_Xdarr(strtrim(line), " ");
		numax_star=data_range[0];
	} else{
		std::cout << "Error! Could not open the star_params.range file created by the Python external routine!" << std::endl;
		std::cout << "The program will exit now" << std::endl;
		exit(EXIT_FAILURE);
	}
	rfile.close();

	tau=input_params[19] * pow(numax_star*1e-6,input_params[20]) + input_params[21]; // Granulation timescale (in seconds)
	H=input_params[16] * pow(numax_star*1e-6,input_params[17]) + input_params[18]; // Granulation Amplitude
	H=H/tau ; //This is due to the used definition for the Harvey profile (conversion from Hz to microHz)
	tau=tau/1000. ; //conversion in ksec
	p=input_params[22];// power law:  MUST BE CLOSE TO 2
	N0=input_params[23];
	noise_params(0,0)=-1;
	noise_params(0,1)=-1;
	noise_params(0,2)=-1; 
	noise_params(1,0)=H;
	noise_params(1,1)=tau;
	noise_params(1,2)=p; 
	noise_params(2, 0)=N0; // White noise
	noise_params(2, 1)=-2;
	noise_params(2, 2)=-2;

	// A FUNCTION THAT WRITES THE Noise
	write_star_noise_params(noise_params, file_out_noise);

}

void asymptotic_mm_v3(VectorXd input_params, std::string file_out_modes, std::string file_out_noise, std::string file_cfg_mm, std::string external_path, std::string template_file){

	int seed=(unsigned)time(NULL);
	srand(seed);
	
	// ----- Constants ------
	const double PI = 3.141592653589793238462643;
	const double G=6.667e-8;
	const double Teff_sun=5777;
	const double Dnu_sun=135.1;
	const double numax_sun=3150;
	const double R_sun=6.96342e5;
	const double M_sun=1.98855e30;
	const double rho_sun=M_sun*1e3/(4*PI*pow(R_sun*1e5,3)/3);
	// ----------------------
	const std::string file_range="external/ARMM-solver/star_params.range";

	//std::cout << "input_params=" << input_params.transpose() << std::endl;
	//std::cout << "input_params.size()=" << input_params.size() << std::endl;
	// ------- Deploy the parameters ------
	double rot_env=input_params[0];
	double rot_core=input_params[1];	
	double Dnu=input_params[2];
	double epsilon=input_params[3];
	double delta0l_percent=input_params[4];
	double beta_p=input_params[5];
	double nmax_spread=input_params[6];
	double DP_var_percent=input_params[7];
	double alpha=input_params[8];
	double q=input_params[9];
	double hnr_l0=input_params[10];
	double l0_width_at_numax=input_params[11];
	double Vl1=input_params[12];
	double Vl2=input_params[13];
	double Vl3=input_params[14];
	double H0_spread=input_params[15];

	double lmax=3;
	double Nmax_pm=6; // Number of radial order to inject on each side of numax
	//double N0=1.; 
	//double Hmax_l0=hnr_l0*N0;
	//double Hmax_l0=-1; // We don't use this anymore because we need to know numax to define the noise N(numax) and then calculate Hmax_l0=H_l0(numax)=hnr_l0(numax)*N(numax)
	double a1;
	
	double numax_star=-1; // This will be defined by bump_DP.py, ... we have to read the output file generated by this code ...
	std::string line;
	VectorXd data_range; // Will contain [numax, fmin, fmax] as derived by the python code

	double H, tau, p, N0;
	MatrixXd noise_params(3,3);

	// ---- Evaluation of DP ----
	// Super rought estimate derived by visual inspection of the Mosser+2015, Fig.1
	const double c=36.8222;
	const double b=2.63897;
	const double a=0.0168202;
	double DP;
	
	DP=a*pow(Dnu, 2) + b*Dnu + c;
	double *r = r8vec_normal_01 ( 1, &seed );
	DP=DP +  *r*DP*DP_var_percent/100.; // Inject a gaussian random error of 2.5%
	// -----------

	// ----------- PYTHON EXTERNAL FUNCTION -------------
	// a. Generate the configuration file for the python function
	int Nchars_spec = 20;
	int precision_spec = 5;
	int sizes;
	
	std::ifstream rfile;
	std::ofstream rwfile;
	
	std::cout << "                     - Attempting to write cfg on file " << file_cfg_mm << "..." << std::endl;
	rwfile.open(file_cfg_mm.c_str());
	if(rwfile.is_open()){
		// ---------------------
		rwfile << "# First line: rot_env / rot_core / Dnu / epsilon / delta0l_percent / beta_p / nmax_spread. Second line: DP1 / alpha / q. Third line coupling / how many l=0 freq on left&right of numax / hmax / width at numax for l=0 / max uniform spread on numax (% or <=0 if off). Fourth line: Noise parameters" << std::endl;
		rwfile << rot_env << std::setw(Nchars_spec) << std::setprecision(precision_spec) << rot_core;
		rwfile << std::setw(Nchars_spec) << std::setprecision(precision_spec) << Dnu;
		rwfile << std::setw(Nchars_spec) << std::setprecision(precision_spec) << epsilon << std::setw(Nchars_spec) << delta0l_percent << std::setw(Nchars_spec) << beta_p;
		rwfile << std::setw(Nchars_spec) << nmax_spread << std::endl;
		rwfile << DP << std::setw(Nchars_spec) << alpha << std::endl;
		rwfile << q << std::setw(Nchars_spec) << Nmax_pm <<  std::setw(Nchars_spec)  << hnr_l0  <<  std::setw(Nchars_spec)  << l0_width_at_numax << std::setw(Nchars_spec) << "-1 " << std::endl;
		rwfile << Vl1 << std::setw(Nchars_spec) << Vl2 << std::setw(Nchars_spec) << Vl3 << std::setw(Nchars_spec) << H0_spread << std::endl;
		rwfile << input_params[16] << std::setw(Nchars_spec) << input_params[17] << std::setw(Nchars_spec) << input_params[18] << std::setw(Nchars_spec); // The noise parameters: P_gran
		rwfile << input_params[19] << std::setw(Nchars_spec) << input_params[20] << std::setw(Nchars_spec) << input_params[21] << std::setw(Nchars_spec); // The noise parameters: tau_gran
		rwfile << input_params[22] << std::setw(Nchars_spec) << input_params[23] << std::endl; //  The noise parameters: N0
		rwfile.close();
		std::cout << "Success... starting python3 external program..." << std::endl;
	} else{
		std::cout << "Error! Could not write the configuration file the Python external routine!" << std::endl;
		std::cout << "The program will exit now" << std::endl;
		exit(EXIT_FAILURE);
	}
	
	// b. Call the external function
	//const std::string str="python3 -c \"import bump_DP; bump_DP.main_star_generator(config_file='external/ARMM-solver/star_params.global', output_file='" + file_out_modes + "', output_file_range='external/ARMM-solver/star_params.range'" + ", output_file_rot='external/ARMM-solver/star_params.rot', version=3)\" ";
	const std::string str="python3 -c \"import bump_DP; bump_DP.main_star_generator(config_file='external/ARMM-solver/star_params.global', filetemplate='" + template_file + "', output_file='" + file_out_modes + "', output_file_range='external/ARMM-solver/star_params.range'" + ", output_file_rot='external/ARMM-solver/star_params.rot', version=3)\" ";
	const char *command = str.c_str(); 
	std::cout << "Executing command line: " << std::endl;
	std::cout << "    "  << str << std::endl;
	
	if (Dnu <= 15){
		std::cout << "    Model with small Dnu ==> many mixed modes. This might be long to find the solutions..." << std::endl; 
	}
	system(command);
	// Retrieve numax from external/ARMM-solver/star_params.range
	rfile.open(file_range.c_str());
	if(rfile.is_open()){
		std::getline(rfile, line); // The first line is a comment ===> We Ignore it
		std::getline(rfile, line); // This is the relevant line
		data_range=str_to_Xdarr(strtrim(line), " ");
		numax_star=data_range[0];
	} else{
		std::cout << "Error! Could not open the star_params.range file created by the Python external routine!" << std::endl;
		std::cout << "The program will exit now" << std::endl;
		exit(EXIT_FAILURE);
	}
	rfile.close();

	tau=input_params[19] * pow(numax_star*1e-6,input_params[20]) + input_params[21]; // Granulation timescale (in seconds)
	H=input_params[16] * pow(numax_star*1e-6,input_params[17]) + input_params[18]; // Granulation Amplitude
	H=H/tau ; //This is due to the used definition for the Harvey profile (conversion from Hz to microHz)
	tau=tau/1000. ; //conversion in ksec
	p=input_params[22];// power law:  MUST BE CLOSE TO 2
	N0=input_params[23];
	noise_params(0,0)=-1;
	noise_params(0,1)=-1;
	noise_params(0,2)=-1; 
	noise_params(1,0)=H;
	noise_params(1,1)=tau;
	noise_params(1,2)=p; 
	noise_params(2, 0)=N0; // White noise
	noise_params(2, 1)=-2;
	noise_params(2, 2)=-2;
	// A FUNCTION THAT WRITES THE Noise
	write_star_noise_params(noise_params, file_out_noise);

}

void asymptotic_mm_freeDp_numaxspread_curvepmodes_v1(VectorXd input_params, std::string file_out_modes, std::string file_out_noise, std::string file_cfg_mm, std::string external_path, std::string template_file){

	int seed=(unsigned)time(NULL);
	srand(seed);

	// ----- Constants ------
	const double PI = 3.141592653589793238462643;
	const double G=6.667e-8;
	const double Teff_sun=5777;
	const double Dnu_sun=135.1;
	const double numax_sun=3150;
	const double R_sun=6.96342e5;
	const double M_sun=1.98855e30;
	const double rho_sun=M_sun*1e3/(4*PI*pow(R_sun*1e5,3)/3);
	// ----------------------
	const std::string file_range="external/ARMM-solver/star_params.range";

	//std::cout << "input_params=" << input_params.transpose() << std::endl;
	//std::cout << "input_params.size()=" << input_params.size() << std::endl;
	// ------- Deploy the parameters ------
	double Teff=input_params[0];
	double Dnu=input_params[1];
	double epsilon=input_params[2];
	double delta0l_percent=input_params[3];
	double beta_p=input_params[4];
	double nmax_spread=input_params[5];
	double DP=input_params[6];
	double alpha=input_params[7];
	double q=input_params[8];
	double hnr_l0=input_params[9];
	double l0_width_at_numax=input_params[10];
	double numax_spread=input_params[11];
	double Vl1=input_params[12];
	double Vl2=input_params[13];
	double Vl3=input_params[14];
	double H0_spread=input_params[15];

	double lmax=3;
	double Nmax_pm=6; // Number of radial order to inject on each side of numax
	//double N0=1.; 
	//double Hmax_l0=hnr_l0*N0;
	//double Hmax_l0=-1; // We don't use this anymore because we need to know numax to define the noise N(numax) and then calculate Hmax_l0=H_l0(numax)=hnr_l0(numax)*N(numax)
	double a1;
	
	double numax_star=-1; // This will be defined by bump_DP.py, ... we have to read the output file generated by this code ...
	std::string line;
	VectorXd data_range; // Will contain [numax, fmin, fmax] as derived by the python code

	double H, tau, p, N0;
	MatrixXd noise_params(3,3);

	// ----------- PYTHON EXTERNAL FUNCTION -------------
	// a. Generate the configuration file for the python function
	int Nchars_spec = 20;
	int precision_spec = 5;
	int sizes;
	
	std::ifstream rfile;
	std::ofstream rwfile;
	
	std::cout << "                     - Attempting to write cfg on file " << file_cfg_mm << "..." << std::endl;
	rwfile.open(file_cfg_mm.c_str());
	if(rwfile.is_open()){
		// ---------------------
		rwfile << "# First line: Teff / Dnu / epsilon / delta0l_percent / beta_p / nmax_spread. Second line: DP1 / alpha / q. Third line coupling / how many l=0 freq on left&right of numax / hmax / width at numax for l=0 / max uniform spread on numax (% or <=0 if off)" << std::endl;
		rwfile << Teff;
		rwfile << std::setw(Nchars_spec) << std::setprecision(precision_spec) << Dnu;
		rwfile << std::setw(Nchars_spec) << std::setprecision(precision_spec) << epsilon << std::setw(Nchars_spec) << delta0l_percent << std::setw(Nchars_spec) << beta_p;
		rwfile << std::setw(Nchars_spec) << nmax_spread << std::endl;
		rwfile << DP << std::setw(Nchars_spec) << alpha << std::endl;
		rwfile << q << std::setw(Nchars_spec) << Nmax_pm <<  std::setw(Nchars_spec)  << hnr_l0  <<  std::setw(Nchars_spec)  << l0_width_at_numax << std::setw(Nchars_spec) << numax_spread/100 << std::endl;
		rwfile << Vl1 << std::setw(Nchars_spec) << Vl2 << std::setw(Nchars_spec) << Vl3 << std::setw(Nchars_spec) << H0_spread << std::endl;
		rwfile << input_params[16] << std::setw(Nchars_spec) << input_params[17] << std::setw(Nchars_spec) << input_params[18] << std::setw(Nchars_spec); // The noise parameters: P_gran
		rwfile << input_params[19] << std::setw(Nchars_spec) << input_params[20] << std::setw(Nchars_spec) << input_params[21] << std::setw(Nchars_spec); // The noise parameters: tau_gran
		rwfile << input_params[22] << std::setw(Nchars_spec) << input_params[23] << std::endl; //  The noise parameters: N0
		rwfile.close();
		std::cout << "Success... starting python3 external program..." << std::endl;
	} else{
		std::cout << "Error! Could not write the configuration file the Python external routine!" << std::endl;
		std::cout << "The program will exit now" << std::endl;
		exit(EXIT_FAILURE);
	}
	
	// b. Call the external function
	//const std::string str="python3 -c \"import bump_DP; bump_DP.main_star_generator(config_file='external/ARMM-solver/star_params.global', output_file='" + file_out_modes + "', output_file_range='external/ARMM-solver/star_params.range'" + ", output_file_rot='external/ARMM-solver/star_params.rot')\" ";
	const std::string str="python3 -c \"import bump_DP; bump_DP.main_star_generator(config_file='external/ARMM-solver/star_params.global', filetemplate='" + template_file + "', output_file='" + file_out_modes + "', output_file_range='external/ARMM-solver/star_params.range'" + ", output_file_rot='external/ARMM-solver/star_params.rot')\" ";
	const char *command = str.c_str(); 
	std::cout << "Executing command line: " << std::endl;
	std::cout << "    "  << str << std::endl;
	
	if (Dnu <= 15){
		std::cout << "    Model with small Dnu ==> many mixed modes. This might be long to find the solutions..." << std::endl; 
	}
	system(command);
	// Retrieve numax from external/ARMM-solver/star_params.range
	rfile.open(file_range.c_str());
	if(rfile.is_open()){
		std::getline(rfile, line); // The first line is a comment ===> We Ignore it
		std::getline(rfile, line); // This is the relevant line
		data_range=str_to_Xdarr(strtrim(line), " ");
		numax_star=data_range[0];
	} else{
		std::cout << "Error! Could not open the star_params.range file created by the Python external routine!" << std::endl;
		std::cout << "The program will exit now" << std::endl;
		exit(EXIT_FAILURE);
	}
	rfile.close();

	tau=input_params[19] * pow(numax_star*1e-6,input_params[20]) + input_params[21]; // Granulation timescale (in seconds)
	H=input_params[16] * pow(numax_star*1e-6,input_params[17]) + input_params[18]; // Granulation Amplitude
	H=H/tau ; //This is due to the used definition for the Harvey profile (conversion from Hz to microHz)
	tau=tau/1000. ; //conversion in ksec
	p=input_params[22];// power law:  MUST BE CLOSE TO 2
	N0=input_params[23];
	noise_params(0,0)=-1;
	noise_params(0,1)=-1;
	noise_params(0,2)=-1; 
	noise_params(1,0)=H;
	noise_params(1,1)=tau;
	noise_params(1,2)=p; 
	noise_params(2, 0)=N0; // White noise
	noise_params(2, 1)=-2;
	noise_params(2, 2)=-2;
	// A FUNCTION THAT WRITES THE Noise
	write_star_noise_params(noise_params, file_out_noise);

}

void asymptotic_mm_freeDp_numaxspread_curvepmodes_v2(VectorXd input_params, std::string file_out_modes, std::string file_out_noise, std::string file_cfg_mm, std::string external_path, std::string template_file){

	int seed=(unsigned)time(NULL);
	srand(seed);
	
	// ----- Constants ------
	const double PI = 3.141592653589793238462643;
	const double G=6.667e-8;
	const double Teff_sun=5777;
	const double Dnu_sun=135.1;
	const double numax_sun=3150;
	const double R_sun=6.96342e5;
	const double M_sun=1.98855e30;
	const double rho_sun=M_sun*1e3/(4*PI*pow(R_sun*1e5,3)/3);
	// ----------------------
	const std::string file_range="external/ARMM-solver/star_params.range";

	//std::cout << "input_params=" << input_params.transpose() << std::endl;
	//std::cout << "input_params.size()=" << input_params.size() << std::endl;
	// ------- Deploy the parameters ------
	double rot_env=input_params[0];
	double rot_ratio=input_params[1];	
	double Dnu=input_params[2];
	double epsilon=input_params[3];
	double delta0l_percent=input_params[4];
	double beta_p=input_params[5];
	double nmax_spread=input_params[6];
	double DP=input_params[7];
	double alpha=input_params[8];
	double q=input_params[9];
	double hnr_l0=input_params[10];
	double l0_width_at_numax=input_params[11];
	double numax_spread=input_params[12];	
	double Vl1=input_params[13];
	double Vl2=input_params[14];
	double Vl3=input_params[15];
	double H0_spread=input_params[16];
	
	double lmax=3;
	double Nmax_pm=6; // Number of radial order to inject on each side of numax
	//double N0=1.; 
	//double Hmax_l0=hnr_l0*N0;
	//double Hmax_l0=-1; // We don't use this anymore because we need to know numax to define the noise N(numax) and then calculate Hmax_l0=H_l0(numax)=hnr_l0(numax)*N(numax)
	double a1;
	
	double numax_star=-1; // This will be defined by bump_DP.py, ... we have to read the output file generated by this code ...
	std::string line;
	VectorXd data_range; // Will contain [numax, fmin, fmax] as derived by the python code

	double H, tau, p, N0;
	MatrixXd noise_params(3,3);

	// ----------- PYTHON EXTERNAL FUNCTION -------------
	// a. Generate the configuration file for the python function
	int Nchars_spec = 20;
	int precision_spec = 5;
	int sizes;
	
	std::ifstream rfile;
	std::ofstream rwfile;
	
	std::cout << "                     - Attempting to write cfg on file " << file_cfg_mm << "..." << std::endl;
	rwfile.open(file_cfg_mm.c_str());
	if(rwfile.is_open()){
		// ---------------------
		rwfile << "# First line: rot_env / rot_ratio / Dnu / epsilon / delta0l_percent / beta_p / nmax_spread. Second line: DP1 / alpha / q. Third line coupling / how many l=0 freq on left&right of numax / hmax / width at numax for l=0 / max uniform spread on numax (% or <=0 if off). Fourth line: Noise parameters" << std::endl;
		rwfile << rot_env << std::setw(Nchars_spec) << std::setprecision(precision_spec) << rot_ratio;
		rwfile << std::setw(Nchars_spec) << std::setprecision(precision_spec) << Dnu;
		rwfile << std::setw(Nchars_spec) << std::setprecision(precision_spec) << epsilon  << std::setw(Nchars_spec) << delta0l_percent << std::setw(Nchars_spec) << beta_p;
		rwfile << std::setw(Nchars_spec) << nmax_spread << std::endl;
		rwfile << DP << std::setw(Nchars_spec) << alpha << std::endl;
		rwfile << q << std::setw(Nchars_spec) << Nmax_pm <<  std::setw(Nchars_spec)  << hnr_l0 ;
		rwfile <<  std::setw(Nchars_spec)  << l0_width_at_numax <<  std::setw(Nchars_spec)  << numax_spread/100 << std::endl;
		rwfile << Vl1 << std::setw(Nchars_spec) << Vl2 << std::setw(Nchars_spec) << Vl3 << std::setw(Nchars_spec) << H0_spread << std::endl;
		rwfile << input_params[17] << std::setw(Nchars_spec) << input_params[18] << std::setw(Nchars_spec) << input_params[19] << std::setw(Nchars_spec); // The noise parameters: P_gran
		rwfile << input_params[20] << std::setw(Nchars_spec) << input_params[21] << std::setw(Nchars_spec) << input_params[22] << std::setw(Nchars_spec); // The noise parameters: tau_gran
		rwfile << input_params[23] << std::setw(Nchars_spec) << input_params[24] << std::endl; //  The noise parameters: N0
		rwfile.close();
		std::cout << "Success... starting python3 external program..." << std::endl;
	} else{
		std::cout << "Error! Could not write the configuration file the Python external routine!" << std::endl;
		std::cout << "The program will exit now" << std::endl;
		exit(EXIT_FAILURE);
	}
	
	// b. Call the external function
	//const std::string str="python3 -c \"import bump_DP; bump_DP.main_star_generator(config_file='external/ARMM-solver/star_params.global', output_file='" + file_out_modes + "', output_file_range='external/ARMM-solver/star_params.range'" + ", output_file_rot='external/ARMM-solver/star_params.rot', version=2)\" ";
	const std::string str="python3 -c \"import bump_DP; bump_DP.main_star_generator(config_file='external/ARMM-solver/star_params.global', filetemplate='" + template_file + "', output_file='" + file_out_modes + "', output_file_range='external/ARMM-solver/star_params.range'" + ", output_file_rot='external/ARMM-solver/star_params.rot', version=2)\" ";
	const char *command = str.c_str(); 
	std::cout << "Executing command line: " << std::endl;
	std::cout << "    "  << str << std::endl;
	
	if (Dnu <= 15){
		std::cout << "    Model with small Dnu ==> many mixed modes. This might be long to find the solutions..." << std::endl; 
	}
	system(command);
	// Retrieve numax from external/ARMM-solver/star_params.range
	rfile.open(file_range.c_str());
	if(rfile.is_open()){
		std::getline(rfile, line); // The first line is a comment ===> We Ignore it
		std::getline(rfile, line); // This is the relevant line
		data_range=str_to_Xdarr(strtrim(line), " ");
		numax_star=data_range[0];
	} else{
		std::cout << "Error! Could not open the star_params.range file created by the Python external routine!" << std::endl;
		std::cout << "The program will exit now" << std::endl;
		exit(EXIT_FAILURE);
	}
	rfile.close();

	tau=input_params[20] * pow(numax_star*1e-6,input_params[21]) + input_params[22]; // Granulation timescale (in seconds)
	H=input_params[17] * pow(numax_star*1e-6,input_params[18]) + input_params[19]; // Granulation Amplitude
	H=H/tau ; //This is due to the used definition for the Harvey profile (conversion from Hz to microHz)
	tau=tau/1000. ; //conversion in ksec
	p=input_params[23];// power law:  MUST BE CLOSE TO 2
	N0=input_params[24];
	noise_params(0,0)=-1;
	noise_params(0,1)=-1;
	noise_params(0,2)=-1; 
	noise_params(1,0)=H;
	noise_params(1,1)=tau;
	noise_params(1,2)=p; 
	noise_params(2, 0)=N0; // White noise
	noise_params(2, 1)=-2;
	noise_params(2, 2)=-2;
	// A FUNCTION THAT WRITES THE Noise
	write_star_noise_params(noise_params, file_out_noise);

}

void asymptotic_mm_freeDp_numaxspread_curvepmodes_v3(VectorXd input_params, std::string file_out_modes, std::string file_out_noise, std::string file_cfg_mm, std::string external_path, std::string template_file){

	int seed=(unsigned)time(NULL);
	srand(seed);
	
	// ----- Constants ------
	const double PI = 3.141592653589793238462643;
	const double Granulation=6.667e-8;
	const double Teff_sun=5777;
	const double Dnu_sun=135.1;
	const double numax_sun=3150;
	const double R_sun=6.96342e5;
	const double M_sun=1.98855e30;
	const double rho_sun=M_sun*1e3/(4*PI*pow(R_sun*1e5,3)/3);
	// ----------------------
	const std::string file_range="external/ARMM-solver/star_params.range";

	//std::cout << "input_params=" << input_params.transpose() << std::endl;
	//std::cout << "input_params.size()=" << input_params.size() << std::endl;
	// ------- Deploy the parameters ------
	double rot_env=input_params[0];
	double rot_core=input_params[1];	
	double Dnu=input_params[2];
	double epsilon=input_params[3];	
	double delta0l_percent=input_params[4];
	double beta_p=input_params[5];
	double nmax_spread=input_params[6];
	double DP=input_params[7];
	double alpha=input_params[8];
	double q=input_params[9];
	double hnr_l0=input_params[10];
	double l0_width_at_numax=input_params[11];
	double numax_spread=input_params[12];
	double Vl1=input_params[13];
	double Vl2=input_params[14];
	double Vl3=input_params[15];
	double H0_spread=input_params[16];

	double lmax=3;
	double Nmax_pm=6; // Number of radial order to inject on each side of numax
	//double N0=1.; 
	//double Hmax_l0=hnr_l0*N0;
	//double Hmax_l0=-1; // We don't use this anymore because we need to know numax to define the noise N(numax) and then calculate Hmax_l0=H_l0(numax)=hnr_l0(numax)*N(numax)
	double a1;
	
	double numax_star=-1; // This will be defined by bump_DP.py, ... we have to read the output file generated by this code ...
	std::string line;
	VectorXd data_range; // Will contain [numax, fmin, fmax] as derived by the python code

	double H, tau, p, N0;
	MatrixXd noise_params(3,3);

	// ----------- PYTHON EXTERNAL FUNCTION -------------
	// a. Generate the configuration file for the python function
	int Nchars_spec = 20;
	int precision_spec = 5;
	int sizes;
	
	std::ifstream rfile;
	std::ofstream rwfile;
	
	std::cout << "                     - Attempting to write cfg on file " << file_cfg_mm << "..." << std::endl;
	rwfile.open(file_cfg_mm.c_str());
	if(rwfile.is_open()){
		// ---------------------
		rwfile << "# First line: rot_env / rot_core / Dnu / epsilon / delta0l_percent / beta_p / nmax_spread. Second line: DP1 / alpha. Third line coupling q / how many l=0 freq on left&right of numax / hmax / width at numax for l=0 / max uniform spread on numax (% or <=0 if off). Fourth line: Noise parameters" << std::endl;
		rwfile << rot_env << std::setw(Nchars_spec) << std::setprecision(precision_spec) << rot_core;
		rwfile << std::setw(Nchars_spec) << std::setprecision(precision_spec) << Dnu;
		rwfile << std::setw(Nchars_spec) << std::setprecision(precision_spec) << epsilon << std::setw(Nchars_spec) << delta0l_percent << std::setw(Nchars_spec) << beta_p;
		rwfile << std::setw(Nchars_spec) << nmax_spread << std::endl;
		rwfile << DP << std::setw(Nchars_spec) << alpha << std::endl;
		rwfile << q << std::setw(Nchars_spec) << Nmax_pm <<  std::setw(Nchars_spec)  << hnr_l0  <<  std::setw(Nchars_spec)  << l0_width_at_numax << std::setw(Nchars_spec);
		rwfile <<  std::setw(Nchars_spec)  << numax_spread/100 << std::endl;
		rwfile << Vl1 << std::setw(Nchars_spec) << Vl2 << std::setw(Nchars_spec) << Vl3 << std::setw(Nchars_spec) << H0_spread << std::endl;
		rwfile << input_params[17] << std::setw(Nchars_spec) << input_params[18] << std::setw(Nchars_spec) << input_params[19] << std::setw(Nchars_spec); // The noise parameters: P_gran
		rwfile << input_params[20] << std::setw(Nchars_spec) << input_params[21] << std::setw(Nchars_spec) << input_params[22] << std::setw(Nchars_spec); // The noise parameters: tau_gran
		rwfile << input_params[23] << std::setw(Nchars_spec) << input_params[24] << std::endl; //  The noise parameters: N0
		rwfile.close();
		std::cout << "Success... starting python3 external program..." << std::endl;
	} else{
		std::cout << "Error! Could not write the configuration file the Python external routine!" << std::endl;
		std::cout << "The program will exit now" << std::endl;
		exit(EXIT_FAILURE);
	}
	
	// b. Call the external function
	const std::string str="python3 -c \"import bump_DP; bump_DP.main_star_generator(config_file='external/ARMM-solver/star_params.global', filetemplate='" + template_file + "', output_file='" + file_out_modes + "', output_file_range='external/ARMM-solver/star_params.range'" + ", output_file_rot='external/ARMM-solver/star_params.rot', version=3)\" ";
	//const std::string str="python3 -c \"import bump_DP; bump_DP.main_star_generator(config_file='external/ARMM-solver/star_params.global', output_file='" + file_out_modes + "', output_file_range='external/ARMM-solver/star_params.range'" + ", output_file_rot='external/ARMM-solver/star_params.rot', version=3)\" ";
	const char *command = str.c_str(); 
	std::cout << "Executing command line: " << std::endl;
	std::cout << "    "  << str << std::endl;
	
	if (Dnu <= 15){
		std::cout << "    Model with small Dnu ==> many mixed modes. This might be long to find the solutions..." << std::endl; 
	}
	system(command);
	
	// Retrieve numax from external/ARMM-solver/star_params.range
	rfile.open(file_range.c_str());
	if(rfile.is_open()){
		std::getline(rfile, line); // The first line is a comment ===> We Ignore it
		std::getline(rfile, line); // This is the relevant line
		data_range=str_to_Xdarr(strtrim(line), " ");
		numax_star=data_range[0];
	} else{
		std::cout << "Error! Could not open the star_params.range file created by the Python external routine!" << std::endl;
		std::cout << "The program will exit now" << std::endl;
		exit(EXIT_FAILURE);
	}
	rfile.close();

	tau=input_params[20] * pow(numax_star*1e-6,input_params[21]) + input_params[22]; // Granulation timescale (in seconds)
	H=input_params[17] * pow(numax_star*1e-6,input_params[18]) + input_params[19]; // Granulation Amplitude
	H=H/tau ; //This is due to the used definition for the Harvey profile (conversion from Hz to microHz)
	tau=tau/1000. ; //conversion in ksec
	p=input_params[23];// power law:  MUST BE CLOSE TO 2
	N0=input_params[24];
	noise_params(0,0)=-1;
	noise_params(0,1)=-1;
	noise_params(0,2)=-1; 
	noise_params(1,0)=H;
	noise_params(1,1)=tau;
	noise_params(1,2)=p; 
	noise_params(2, 0)=N0; // White noise
	noise_params(2, 1)=-2;
	noise_params(2, 2)=-2;

	// A FUNCTION THAT WRITES THE Noise
	write_star_noise_params(noise_params, file_out_noise);
}





// ------------------------------------
// ------- MAIN SEQUENCE MODELS ------
// ------------------------------------

void generate_cfg_asymptotic_act_asym_Hgauss(VectorXd input_params, std::string file_out_modes, std::string file_out_noise){

	// ----- Constants ------
	const double PI = 3.141592653589793238462643;
	const double G=6.667e-8;
	const double Teff_sun=5777;
	const double Dnu_sun=135.1;
	const double numax_sun=3150;
	const double R_sun=6.96342e5;
	const double M_sun=1.98855e30;
	const double rho_sun=M_sun*1e3/(4*PI*pow(R_sun*1e5,3)/3);

    std::cout << "      generate_cfg_asymptotic_act_asym_Hgauss" << std::endl;

	VectorXd Visibilities(4);
	Visibilities << 1, 1.5, 0.5, 0.08;
	// ----------------------

	double ks=2; // controls the width of the gaussian for heights

	//std::cout << "input_params=" << input_params.transpose() << std::endl;
	//std::cout << "input_params.size()=" << input_params.size() << std::endl;
	// ------- Deploy the parameters ------
	double numax=input_params[0];
	double Dnu=input_params[1];
	double epsilon=input_params[2];
	double D0=input_params[3];
	double Max_Height=input_params[4];
	double Width=input_params[5];
	double lmax=input_params[6];
	int    Nmax=input_params[7];
	double a1=input_params[8];
	double a3=input_params[9];
	double b=input_params[10];
	double alfa=input_params[11];
	double beta_asym=input_params[12];
	double inc=input_params[13];	
	VectorXd input_noise(9);
	if((input_params.size() - 14) == 9){
		input_noise=input_params.segment(14, 9);
	} else{ // If we did not provide 3 lines of 3 elements, then this means that we have 2 lines of 3 elements + 1 line with one elements (7 parameters)
		input_noise.segment(0, 7)=input_params.segment(14, 7);
		input_noise[7]=-2;
		input_noise[8]=-2;
	}
	// ------------------------------------

    //std::cout << "           - Variables..." << std::endl;

	// --------- Variables ---------
	int k;
	double el, en, n_at_numax, height, eta;
	VectorXd en_list(Nmax);
	MatrixXd nu(int(lmax+1), Nmax), h(int(lmax+1), Nmax), w(int(lmax+1), Nmax), s_a1(int(lmax+1), Nmax), s_eta(int(lmax+1), Nmax), 
		 s_a3(int(lmax+1), Nmax), s_asym(int(lmax+1), Nmax), s_b(int(lmax+1), Nmax), s_alfa(int(lmax+1), Nmax), i(int(lmax+1), Nmax), 
		 mode_params(int(lmax+1)*Nmax, 11), noise_params(3,3);
	// -----------------------------

	if((Nmax % 2) !=0){
		std::cout << "Nmax must be a odd number. Please change that value accordingly" << std::endl;
		std::cout << "The program will exit now" << std::endl;
		exit(EXIT_FAILURE);
	}

	k=0;
	n_at_numax=numax/Dnu - epsilon + el/2 + el*(el+1)*D0/Dnu;
	for(en=-Nmax/2 + 1; en<=Nmax/2; en++){
		en_list[k]=floor(n_at_numax) + en;
		k=k+1;
	}	

	// Define the centrifugal force effect	
	eta=(4./3)*PI * pow( a1*1e-6 ,2) / (G * rho_sun) * pow(Dnu_sun/Dnu,2);
	//std::cout << "Fixing centrifugal term eta = " << eta << std::endl;
	
	// Create a list of frequencies, Height, Width, Splitting, Centrifugal terms, latitudinal terms and stellar inclination

    //std::cout << "           - Parameters..." << std::endl;
    
	for(el=0; el<=lmax; el++){
		for(en=0; en<Nmax; en++){
			if(el == 0 || el == 1){
				nu(el,en)=(en_list[en] + epsilon + el/2)*Dnu - el*(el + 1)*D0;
			}
			if(el == 2 || el == 3){
				nu(el,en)=(en_list[en]-1 + epsilon + el/2)*Dnu - el*(el + 1)*D0;
			}
			if(el > 3){
				std::cout << "Generating frequencies with degree higher than l=3 is not implemented" << std::endl;
				std::cout << "Please set lmax<4" << std::endl;
				std::cout << "The program will exit now" << std::endl;
				exit(EXIT_FAILURE);
			}
			
			height=Max_Height*exp(-0.5 * pow( (nu(el, en) - numax)/(ks*Dnu), 2));
			h(el, en)=height*Visibilities[el];

			w(el,en)=Width;

			s_a1(el,en)=a1;
			s_eta(el,en)=eta;
			s_a3(el,en)=a3;
			s_b(el,en)=b;
			s_alfa(el,en)=alfa;
			s_asym(el,en)=beta_asym;
			i(el,en)=inc;
			/*			
			std::cout << "en_list[en]=" << en_list[en] << std::endl;
			std::cout << "nu(el,en)=" << nu(el,en) << std::endl;
			std::cout << "s_a1(el,en)=" << s_a1(el,en) << std::endl;
			std::cout << "s_eta(el,en)=" << s_eta(el,en) << std::endl;
			std::cout << "s_a3(el,en)=" << s_a3(el,en) << std::endl;
			std::cout << "s_b(el,en)=" << s_b(el,en) << std::endl;
			std::cout << "s_alfa(el,en)=" << s_alfa(el,en) << std::endl;
			std::cout << "s_asym(el,en)=" << s_asym(el,en) << std::endl;
			std::cout << "i(el,en)=" << i(el,en) << std::endl;
			std::cout << "--------------" << std::endl;
			*/
		}
	}

    //std::cout << "           - mode_params preparation..." << std::endl;

	// Summarizing the information into a parameter table
	for(el=0; el<=lmax; el++){
		for(k=el*Nmax; k<(el+1)*Nmax; k++){
			mode_params(k,0)=el;
			mode_params(k,1)=nu(el , k-el*Nmax);
			mode_params(k,2)=h(el , k-el*Nmax);
			mode_params(k,3)=w(el , k-el*Nmax);
			mode_params(k,4)=s_a1(el , k-el*Nmax);
			mode_params(k,5)=s_eta(el , k-el*Nmax);
			mode_params(k,6)=s_a3(el , k-el*Nmax);
			mode_params(k,7)=s_b(el , k-el*Nmax);
			mode_params(k,8)=s_alfa(el , k-el*Nmax);
			mode_params(k,9)=s_asym(el , k-el*Nmax);
			mode_params(k,10)=i(el , k-el*Nmax);
		}
	}
	

	// A FUNCTION THAT WRITES THE PARAMETERS
	write_star_mode_params_act_asym(mode_params, file_out_modes);

    //std::cout << "           - Noise..." << std::endl;

	// Defining the noise profile parameters
	// Note about the noise: -1 means that it is ignored. -2 mean that the value is irrelevant
	for(int e=0; e<3; e++){
		for(int k=0; k<3; k++){
			noise_params(e, k)=input_noise(3*e + k);
		}
	}
	// A FUNCTION THAT WRITES THE Noise
	write_star_noise_params(noise_params, file_out_noise);

    //std::cout << "           - Exit" << std::endl;


}

/* 
	This function use a reference star as a template to generate frequencies and Width, Height profiles
	can be rescaled so that you can modify the HNR but keep the same height profile
	Note that the user here provides a target a1/Width so that a1 is automatically adjusted to match the 
	requested a1/Width. The code will not change the Width so that code is not adapted to test blending between adjacent l modes,
	such as the l=0 and l=2 mode blending. 
*/
void generate_cfg_from_synthese_file_Wscaled_act_asym_a1ovGamma(VectorXd input_params, std::string file_out_modes, std::string file_out_noise, std::string extra){

	int i;
	double N0, HNR, a1_ov_Gamma, a3, beta_asym, inc, HNRmaxref, Height_factor, Gamma_at_numax, a1, Gamma_coef; 
	VectorXi pos_max;
	VectorXd tmp;
	VectorXd HNRref, local_noise,h_star, gamma_star, s_a1_star, s_a3_star, s_asym_star, inc_star;
	Star_params ref_star;
	MatrixXd mode_params, noise_params;

	ref_star=read_star_params(extra); 

	// Defining the noise profile parameters
	// Note about the noise: -1 means that it is ignored. -2 mean that the value is irrelevant
	tmp.resize(ref_star.mode_params.rows()); 	
	tmp.setConstant(0);
	local_noise=harvey_like(ref_star.noise_params, ref_star.mode_params.col(1), tmp); // Generate a list of local noise values for each frequencies

// ---- Deploy the parameters -----
	HNR=input_params[0];
	a1_ov_Gamma=input_params[1];
	Gamma_at_numax=input_params[2];
	a3=input_params[3];
	beta_asym=input_params[4];
	inc=input_params[5];
// ---------------------------------

	HNRref=ref_star.mode_params.col(2);
	HNRref=HNRref.cwiseProduct(local_noise.cwiseInverse());
	HNRmaxref=HNRref.maxCoeff(); // This is the maximum HNR of the reference data
	Height_factor=HNR/HNRmaxref;  // compute the coeficient required to get the proper max(HNR)

	tmp=ref_star.mode_params.col(2);
	pos_max=where_dbl(ref_star.mode_params.col(2), tmp.maxCoeff(), 0.001);
	if (pos_max[0] >= 0){
		Gamma_coef=Gamma_at_numax/ref_star.mode_params(pos_max[0], 3); // Correction coeficient to apply on Gamma(nu) in order to ensure that we have Gamma(nu=numax) = Gamma_at_numax
	} else{
		std::cout << "Error! could not find the max position for the mode Widths profile" << std::endl;
		std::cout << "Code debug required" << std::endl;
		exit(EXIT_FAILURE);
	}

	a1=a1_ov_Gamma*Gamma_at_numax; // We can vary the Width and splitting. But we need to change the splitting in order to get the wished a1/Gamma0

	std::cout << "after a1" << std::endl;
	if (local_noise.sum()!= 0){
		N0=1; // Imposing the the Noise background is 1
		std::cout <<  "Using N0=" << N0 << " (white noise)" << std::endl;
		std::cout << "HNR of all modes (degree / freq / HNR):" << std::endl;
		for(i =0; i<ref_star.mode_params.rows(); i++){
			std::cout << "     " << ref_star.mode_params(i,0) << "  " << ref_star.mode_params(i,1) << "  " << Height_factor * HNRref[i] << std::endl;
		}
	} else{
		std::cout << "Warning: bruit_local from the stat_synthese file is 0 ==> Cannot compute N0=mean(local_noise)" << std::endl;
		std::cout << "         The program will stop now" << std::endl;
		exit(EXIT_FAILURE);
	}

	// Defining the final size for all of the outptus
	h_star.resize(ref_star.mode_params.rows());
	gamma_star.resize(ref_star.mode_params.rows());
	s_a1_star.resize(ref_star.mode_params.rows());
	s_a3_star.resize(ref_star.mode_params.rows());	
	s_asym_star.resize(ref_star.mode_params.rows());
	inc_star.resize(ref_star.mode_params.rows());

	// Refactoring the heights
	h_star=Height_factor * HNRref * N0; 

	gamma_star=Gamma_coef*ref_star.mode_params.col(3); // In IDL, AN INTERPOLATION WAS DONE FOR l>0. HERE WE ASSUME THE .in file is whatever the true model should be (no interpolation)
	
	if (a1 >= 0){
		s_a1_star.setConstant(a1);
	} else{
		s_a1_star=ref_star.mode_params.col(4); 
	}
	if (a3 >= 0){
		s_a3_star.setConstant(a3);	
	} else{
		s_a3_star=ref_star.mode_params.col(6);	
	}
	if (beta_asym >= 0){
		s_asym_star.setConstant(beta_asym);	
	} else{
		s_asym_star=ref_star.mode_params.col(9);	
	}	
	if (inc >= 0){ 
		inc_star.setConstant(inc);
	} else{
		inc_star=ref_star.mode_params.col(10);
	}
	
	mode_params.setZero(ref_star.mode_params.rows(), 11);

	mode_params.col(0)=ref_star.mode_params.col(0); // List of els
	mode_params.col(1)=ref_star.mode_params.col(1); // List of frequencies
	mode_params.col(2)=h_star;
	mode_params.col(3)=gamma_star; 
	mode_params.col(4)=s_a1_star; 
	mode_params.col(5).setConstant(0); //ref_star.mode_params.col(5); // asphericity coefficient depends on a1, cannot use the one from the ref_star
	mode_params.col(6)=s_a3_star;
	//mode_params.col(7])=0;   // Already to 0 due to initialisation
	//mode_params.col(8)=0;   // Already to 0 due to initialisation
	mode_params.col(9)=s_asym_star;
	mode_params.col(10)=inc_star;  

	// A FUNCTION THAT WRITES THE PARAMETERS
	write_star_mode_params_act_asym(mode_params, file_out_modes);

	// A FUNCTION THAT WRITES THE Noise
	write_star_noise_params(ref_star.noise_params, file_out_noise);
}

/*
// small test program
int main(){

	VectorXd input_params;
	std::string file_out_modes;
	std::string file_out_noise;

	file_out_modes="file_params.txt";
	file_out_noise="file_noise.txt";

	input_params.setZero(14 +9);
	input_params << 2000., 90., 0.2, 1.35, 10., 5., 3, 16, 1.0, 0.025, -0.05, 3., 50., 90, -1, -1, -1, -1, -1, -1, 0.1, -2, -2;  
	//generate_cfg_asymptotic_Hgauss(input_params, file_out_modes, file_out_noise);
	generate_cfg_asymptotic_act_asym_Hgauss(input_params, file_out_modes, file_out_noise);
	std::cout << "End" << std::endl;
}
*/
